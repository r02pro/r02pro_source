[["index.html", "R Programming: Zero to Pro Preface", " R Programming: Zero to Pro Yang Feng and Jianan Zhu 2021-10-05 Preface This book is for anyone who is interested in learning R and Data Science. It is designed for people with zero background in programming. We also have a companion R package named r02pro, containing the data sets used as well as interactive exercises for each part. If you have any questions or feedback (including typos or grammar issues) about any materials in the book, we greatly appreciate if you can write to us at r02pro007@gmail.com. We will also add your name in the Acknowledgement section to show our gratitude. "],["acknowledgement.html", "Acknowledgement", " Acknowledgement This book is the product of numerous collaborative efforts. Among all people, we are most grateful to the students in the course GPH-GU 2183: Introduction to Statistical Programming in R in Fall 2021 at New York University. The list of people that made contribution include Xiaofeng Yang (@well9801), Neethu Grace Johnson "],["introduction.html", "Chapter 1 Introduction", " Chapter 1 Introduction This chapter begins with the installation of R, RStudio, and R Packages in Section 1.1, shows how to use R as a fancy calculator in Section 1.2, and introduce how to do object assignments in Section 1.3. "],["Installation.html", "1.1 Installation of R, RStudio and R Packages", " 1.1 Installation of R, RStudio and R Packages 1.1.1 Download and Install As a first step, you need to download R and RStudio, whose links are as follows. For both software, you need to choose the version that corresponds to your operation system. Download R: https://cloud.r-project.org/ Download RStudio: https://rstudio.com/products/rstudio/download/#download RStudio is an Integrated Development Environment for R, which is powerful yet easy to use. Throughout this book, you will use RStudio instead of R to learn R programming. Next, let’s get started with a quick tour of RStudio. 1.1.2 RStudio Interface After opening RStudio for the first time, you may find that the font and button size is a bit small. Let’s see how to customize the appearance. a. Customize appearance On the RStudio menu bar, you can click Tools, and then click on Global Options as shown in the following figure. Figure 1.1: Global Options Then, you will see a window pops up like Figure 1.2. After clicking on Appearance, you can see several drop-down menus including Zoom and Editor font size, among other choices shown. Zoom controls the overall scale for all elements in RStudio interface, including the sizes of menu, buttons, as well as the fonts. Editor font size controls the size of the font only in the code editor. After adjusting the appearance, you need to click on Apply to save our settings. Figure 1.2: Zoom and Editor font size Here, we change the Zoom to 150% and set the Editor font size to 18. b. Four panels of RStudio Now, the RStudio interface is clearer with bigger font size. Although RStudio has four panels, not all of them are visible to us at the beginning (Figure 1.3). Figure 1.3: Unfold panels In Figure 1.3, we have labeled three useful buttons as 1, 2, and 3. By clicking buttons 1 and 3, you can reveal the two hidden panels.1 By clicking button 2, we can clear the content in the bottom left panel as shown in the following figure. Figure 1.4: Four panels Now, let’s take a close look at all four panels, which are labeled as 1-4 in Figure 1.4. You can change the size of each panel by dragging the two blue slides up or down and the green slide left or right. Panels 1 and 2 are located to the left of the green line, and are collectively called the Code Area. We will introduce them in the following parts of this section. Panels 3 and 4 are located to the right of the green line, and are collectively called R Support Area. We will introduce these two panels in later sections. c. Console Now, let’s introduce the panel 2 in Figure 1.4, which is usually called the Console. By clicking the mouse on the line after the &gt; symbol, you can see a blinking cursor, indicating that R is ready to accept codes. Let’s type 1 + 2 and press Return (on Mac) or Enter (on Windows). It is a good habit to add spaces around an operator to increase readability of the code. Figure 1.5: Writing code in the console Hooray! You have successfully ran our first piece of R code and gotten the correct answer 3. Note that the blinking cursor now appears on the next line, ready to accept a new line of code. Figure 1.6: R code(2) Although the console may work well for some quick calculations, you need to resort to the panel 1 in Figure 1.4 (usually called the Editor) to save our work and run multiple lines of code at the same time. d. Save R codes as scripts The Editor panel is the go-to place to write complicated R codes, which you can save as R scripts for repeated use in the future. Firstly, we will introduce how to run codes in scripts. Let’s go to the editor and type 1 + 2. To run this line of code, you can click the Run button. The keyboard shortcut of running this line of code is Cmd+Return on Mac or Ctrl+Enter on Windows. Figure 1.7: script RStudio will then send the line of code to the console and execute the code. Several lines here After finishing writing codes in the editor, you can save them as a script. To do that, you can click the Save button as shown in the Figure 1.8. The keyboard shortcut of saving files is Cmd+S on Mac or Ctrl+S on Windows. Figure 1.8: Save (I) Then you would see a pop-up file dialog box, asking you for a file name and location to save it to. Let’s call it lesson1.1 here. Figure 1.9: Save (II) After saving files successfully, you can confirm the name of the R script on the top. Figure 1.10: Save (III) Lastly, if you want to create a new R script, you can click the + button on the menu, then select R Script. Then you will see a new file created. Add a screenshot here Note that there are quite a few other options including R Markdown, which will be introduced in Section 11. Figure 1.11: create a new script 1.1.3 Install and load R packages Now, you have had a basic understanding of RStudio, it is time to introduce R packages, which greatly extend the capabilities of base R. There are a large number of publicly available R packages. As of July 2021, there are more than 17K R packages on Comprehensive R Archive Network (CRAN), with many others located in Bioconductor, GitHub, and other repositories. To install an R package, you need to use a built-in R function , which is install.packages(). A function takes in arguments (inputs) and performs a specific task. After the function name, we always need to put a pair of parentheses with the arguments inside. While there are many built-in R functions, R packages usually contain many useful functions as well, and we can also write our own functions, which will be introduce in Chapter 10. With install.packages(), the argument is the package name with a pair of quotation marks around it. The task it performs is installing the specific package into R. Here, you will install the companion package for this book, named r02pro, a.k.a. R Zero to Pro. The r02pro package contains several data sets that will be used throughout the book, and interactive exercises for each subsection. install.packages(&quot;r02pro&quot;) If you miss the right parenthesis, R will show a plus on the next line (as shown in Figure 1.12), waiting for more input to complete the command. If this happens, you can either enter the right parenthesis, or press ESC to escape this command. When you see a blinking cursor after the &gt; symbol, you can write new codes again. Figure 1.12: Miss the right parenthesis After a package is installed, you still need to load it into R before using it. To load a package, you can use the library() function with the package name as its argument. Here, the quotation marks are not necessary. library(r02pro) Note that once a package is installed, you don’t need to install it again on the same machine. However, when starting a new R session, you would need to load the package again. Quotation marks are necessary for installing R packages, but are not necessary for loading packages. If we install packages without quotation marks. We will see an error message, showing object not found. install.packages(r02pro) 1.1.4 Exercises Which of the following code using to install packages into R will cause an error? install.packages(\"r02pro\") install.packages(r02pro) Write R code to load the package r02pro Write R code to calculate 2 + 3. Note that you may see different panels hidden when you open RStudio for the first time, depending on the RStudio version. However, you can always reveal the hidden panels by clicking the corresponding buttons like Buttons 1 and 3 in Figure 1.3.↩︎ "],["Calculator.html", "1.2 Use R as a Fancy Calculator", " 1.2 Use R as a Fancy Calculator While R is super powerful, it is, first of all, a very fancy calculator. 1.2.1 Add comments using “#” The first item we will cover is about adding comments. In R, you can add comments using the pound sign #. In each line, anything after # are comments, which will be ignored by R. Let’s see an example, 6 - 1 / 2 #first calculate 1/2=0.5, then 6-0.5=5.5 #&gt; [1] 5.5 Just looking at the resulting value 5.5, you may not know the detail of the calculation process. The comment informs you the operation order: the division is calculated before the subtraction. In general, adding comments to codes is a very good practice, as it greatly increases readability and make collaboration easier. We will also add many comments in our codes to help you learn R. 1.2.2 Basic calculation Now let’s start to use R as a calculator! You can use R to do addition, subtraction, multiplication，division, and combine multiple basic operations. You can also calculate the square root, absolute value and the sign of a number. Operation Explanation 1 + 2 addition 1 - 2 subtraction 2 * 4 multiplication 2 / 4 division 6 - 1 / 2 multiple operations sqrt(100) square root abs(-3) absolute value sign(-3) sign While the first seven operations in the table look intuitive, you may be wondering, what does the sign() function mean here? Is it a stop sign? Sometimes, you may have no idea how a particular function works. Fortunately, R provides a detailed documentation for each function. There are three ways to ask for help in R. Use a question mark followed by the function name, e.g. ?sign Use help function, e.g. help(sign) Use the help window in RStudio, as shown in Figure 1.13. The help window is the panel 4 of Figure 1.4 in Section 1.1. Then type in the function name in the box to the right of the magnifying glass and press return. Figure 1.13: Ask for help 1.2.3 Approximation After learning about doing basic calculations, let’s move on to do approximation in R. When you do division, for example, when computing 7 / 3, the answer is not a whole number since 7 is not divisible by 3. Under these circumstances, approximation operators are very handy to use. Let’s take 7 / 3 as the example. a. Get the integer part and the remainder Code Name 7%/%3 integer division 7%%3 modulus We all know that 7 = 3 * 2 + 1. So the integer division will pick up the integer part, which is 2 here; and the modulus will get the remainder, which is 1. b. Get the nearby integer floor(7 / 3) #&gt; [1] 2 ceiling(7 / 3) #&gt; [1] 3 Since 2 &lt;= 7/3 &lt;= 3, you can use the floor function to find the largest integer &lt;= 7/3, which is 2; and the ceiling function gives the smallest integer &gt;= 7/3, which is 3. c. Round to the nearest number round(7 / 3) #&gt; [1] 2 round(7 / 3, digits = 3) #&gt; [1] 2.333 The round() function follows the rounding principle. By default, you will get the nearest integer to 7 / 3, which is 2. If you want to control the approximation accuracy, you can add a digits argument to specify how many digits you want after the decimal point. Here you will get 2.333 after adding digits = 3. 1.2.4 Power &amp; logarithm You can also use R to do power and logarithmic operations. Generally, you can use ^ to do power operations. For example, 10^5 will give us 10 to the power of 5. Here, 10 is the base value, and 5 is the exponent. The result is 100000, but it is shown as 1e+05 in R. That’s because R uses the so-called scientific notation. scientific notation: a common way to express numbers which are too large or too small to be conveniently written in decimal form. Generally, it expresses numbers in forms of \\(m \\times 10^n\\) and R uses the e notation. Note that the e notation has nothing to do with the natural number \\(e\\). Let’s see some examples, \\[\\begin{align} 1 \\times 10^5 &amp;= \\mbox{1e+05}\\\\ 2 \\times 10^4 &amp;= \\mbox{2e+04}\\\\ 1.2 \\times 10^{-3} &amp;= \\mbox{1.2e-03} \\end{align}\\] In mathematics, the logarithmic operations are inverse to the power operations. If \\(b^y = x\\) and you only know \\(b\\) and \\(x\\), you can do logarithm operations to solve \\(y\\) using the general form \\(y = \\log(x, b)\\), which is called the logarithm of \\(x\\) with base \\(b\\). In R, logarithm functions with base value of 10, 2, or the natural number \\(e\\) have shortcuts log10(), log2(), and log(), respectively. Let’s see an example of log10(), the logarithm function with base 10. 10^6 #&gt; [1] 1e+06 log10(1e6) #log10(x) = log(x, 10) #&gt; [1] 6 Next, let’s see log2(), the logarithm function with base 2. 2^10 #&gt; [1] 1024 log2(1024) #log2(x) = log(x, 2) #&gt; [1] 10 Before moving on to the natural logarithm, note that the natural number \\(e\\) needs to be written as exp(1) in R. When you want to do power operations on \\(e\\), you can simply change the argument in the function exp(), for example, exp(3) is \\(e\\) to the power of 3. Here, log() without specifying the base argument represents the logarithm function with base \\(e\\). exp(1) #&gt; [1] 2.718282 exp(3) #&gt; [1] 20.08554 log(exp(3)) #log(x) = log(x, exp(1)) #&gt; [1] 3 1.2.5 Trigonometric function R also provides the common trigonometric functions. cos(pi) #&gt; [1] -1 acos(-1) #&gt; [1] 3.141593 Here, acos() is the inverse function of cos(). If we set \\(cos(a) = b\\), then we will get \\(acos(b) = a\\). sin(pi/2) #&gt; [1] 1 asin(1) #&gt; [1] 1.570796 Similarly, asin() is the inverse function of sin(). If we set \\(sin(a) = b\\), then we will get \\(asin(b) = a\\). tan(pi/4) #&gt; [1] 1 atan(1) #&gt; [1] 0.7853982 Also, atan() is the inverse function of tan(). If we set \\(tan(a) = b\\), then we will get \\(atan(b) = a\\). 1.2.6 Exercises Write R code to compute \\(\\sqrt{5 \\times 5}\\). Write R code to get help on the function floor. Write R code to compute the square of \\(\\pi\\) and round it to 4 digits after the decimal point. Write R code to compute the logarithm of 1 billion with base 1000. Write R code to verify \\(sin^2(x) + cos^2(x) = 1\\), for \\(x = 724\\). "],["Object-Assignment.html", "1.3 Object Assignment", " 1.3 Object Assignment In the last section, you have seen the power of R as a fancy calculator. However, in order to do more complicated and interesting tasks, you may need to store intermediate results for future use. Let’s take a look at a concrete example. Say if you want to do the following calculations involving exp(3) / log(20,3) * 7. (exp(3) / log(20,3) * 7) + 3 #addition (exp(3) / log(20,3) * 7) - 3 #subtraction (exp(3) / log(20,3) * 7) / 3 #division You need to type the expression exp(3) / log(20,3) * 7 three times, which is a bit cumbersome. In this section, we will introduce how to assign the value of the exp(3) / log(20,3) * 7 to a name for future use. Then, for any operation involving exp(3) / log(20,3) * 7, you can just use the corresponding name instead. 1.3.1 What is an R Object? Firstly, we will introduce the most important thing in R, which is called object. In principle, everything that exists in R is an object. For example, the number 5 is an object, the expression 1 + 2 is an object, and floor(7 / 3) is also an object. In the above examples, there is only one element in the result of each object. However, the object can contain more than one elements in the result, and each element has its own value. Notice that different elements can have the same value. Values can be of three types including numerical, character, and logical. For example, 1 + 2 is an object with one element of value 3. 1.3.2 Assignment Operation with &lt;- Knowing the importance of objects, let’s introduce how to do object assignments in R. To do object assignments, you need to assign value(s) to a name via the assignment operator, which will create a new object with a name. You can use the new named object once it is created in subsequent calculations without redundancy. Let’s start with a simple example, x_numeric &lt;- 5 The assignment operation has three components. From left to right， the first component x_numeric is the object name of a new object, which has certain naming rules which we will discuss shortly in Section 1.3.4. The second component is the assignment operator &lt;-, which is a combination of the less than sign &lt; immediately followed by the minus sign -. The final component is the value(s) to be assigned to the name, which is 5 here. There is no space between &lt; and - in the assignment operator &lt;-. Note that although = may also appear to be working as the assignment operator, it is not recommended as = is usually reserved for specifying the value(s) of arguments in a function call, which will be introduced in Section 2.3. After running the code above, you will see no output in the console, unlike the case when we ran 1 + 2 which gives us the answer 3 (as shown in the Figure 1.14). You may be wondering, did we successfully make our first assignment operation? Figure 1.14: No output To verify it, you can run the code with just the object name to check its value. (For named objects, you can get their value(s) by running codes with their object names.) x_numeric #&gt; [1] 5 Great! You get the value 5, indicating that you have successfully assigned the value 5 to the name x_numeric, and you have created a new object x_numeric. You can use x_numeric instead of 5 to do the subsequent calculations because x_numeric and 5 have the same value. You can also assign value(s) of any R expression (including operations and functions) to a name. Let’s try to simplify the three expressions we did at the beginning of this section. It is easy to observe that the three lines of codes share a common term exp(3) / log(20,3) * 7. Let’s assign the value of the common term to a name. y_numeric &lt;- exp(3) / log(20,3) * 7 y_numeric #&gt; [1] 51.56119 Here, R will first calculate the result of exp(3) / log(20,3) * 7 and assign the value of the result to y_numeric. Now you have successfully created an object y_numeric with value 51.56119. Using the named object y_numeric, you can simplify the three calculations as follows. y_numeric + 3 y_numeric - 3 y_numeric / 3 You can also try the following examples by yourself. a &lt;- floor(7 / 3) a b &lt;- 7%/%3 b Clearly, using the object assignment, you can greatly simplify your code and avoid redundancy. Note that R object names are case-sensitive. For example, you have defined x_numeric, but if you type X_numeric, you will get an error message as follow. X_numeric #&gt; Error in eval(expr, envir, enclos): object &#39;X_numeric&#39; not found 1.3.3 Review objects in environment After creating new objects x_numeric and y_numeric, they will appear in the Environment, located in the top right panel (panel3 in Figure 1.4). You can check all the named objects and their values in this area. It is helpful to monitor the environment from time to time to make sure everything look fine. Notice that objects without names will not be shown in the environment. You can also see the list of all the named objects using function ls(). ls() #&gt; [1] &quot;a&quot; &quot;ani_char&quot; #&gt; [3] &quot;animal&quot; &quot;animal_tidy&quot; #&gt; [5] &quot;animal_wide&quot; &quot;animal_wide_weight&quot; #&gt; [7] &quot;b&quot; &quot;char_mat&quot; #&gt; [9] &quot;Code&quot; &quot;contributors&quot; #&gt; [11] &quot;d&quot; &quot;data_type&quot; #&gt; [13] &quot;dig_num&quot; &quot;dig_num_new&quot; #&gt; [15] &quot;Dim&quot; &quot;Explanation&quot; #&gt; [17] &quot;key_mat&quot; &quot;Keys&quot; #&gt; [19] &quot;m1&quot; &quot;m2&quot; #&gt; [21] &quot;my_list&quot; &quot;my_vec&quot; #&gt; [23] &quot;n&quot; &quot;Name&quot; #&gt; [25] &quot;norm_dat&quot; &quot;norm_dat_1&quot; #&gt; [27] &quot;norm_dat_2&quot; &quot;norm_dat_3&quot; #&gt; [29] &quot;Operation&quot; &quot;p&quot; #&gt; [31] &quot;para_1&quot; &quot;para_2&quot; #&gt; [33] &quot;Pattern&quot; &quot;q&quot; #&gt; [35] &quot;Section&quot; &quot;Type&quot; #&gt; [37] &quot;w&quot; &quot;weight&quot; #&gt; [39] &quot;x&quot; &quot;x_numeric&quot; #&gt; [41] &quot;x1&quot; &quot;x2&quot; #&gt; [43] &quot;x3&quot; &quot;y_numeric&quot; #&gt; [45] &quot;year&quot; &quot;z&quot; All the objects shown in the environment or the list have been saved in R, so they are available for future use directly. It is a good habit to do object assignments if you want to save important values for future use. 1.3.4 Object naming rule Now you have created two named objects x_numeric and y_numeric. In general, R is very flexible in the name you give to an object，however, there are three important rules you need to follow. a. Must start with a letter or . (period) If starting with period, the second character can’t be a number. b. Can only contain letters, numbers, _ (underscore), and . (period) One recommended naming style is to only use lowercase letters and numbers, and use underscore to separate words within a name. So you can use relatively longer names that is more readable. c. Can not use special keywords as names. For example, TRUE &lt;- 12 is not permitted as TRUE is a special keyword in R. You can see from the following that this assignment operation leads to an error message. TRUE &lt;- 12 #&gt; Error in TRUE &lt;- 12: invalid (do_set) left-hand side to assignment Some commonly used reserved keywords that cannot be used as names are listed as below. break NA else NaN FALSE next for repeat function return if TRUE Inf while To get a complete list of reserved words, you can run the following code. ?Reserved 1.3.5 Object types In this section, you have learned about how to assign a value to a name. The values you assigned are all of numeric type. Actually, an object may contain more than one values. Also, the values it contains can be of other types than numeric, including character and logical. Depending on the composition of values, the object belongs to one particular type. Type Section Vector 2.1 Matrix 3.1 Array 3.2 Data Frame 3.3 List 3.4 We will focus on vectors in Chapter 2 and discuss other object types in Chapter 3. While some of the object types look more intuitive than others, you have nothing to worry about since we have the next two chapters devoted to the details of R objects. Objects are the building blocks of R programming and it will be time well spent mastering every object type. 1.3.6 Exercises Write R code to assign the value 20 to the name num_1. Which of the following is a valid object name in R? 2.True else I_am_not_a_valid_name I_am_a_Pretty#_name Write R code to get the list of all objects in the environment. "],["r-objects.html", "Chapter 2 R Objects (I): Vectors", " Chapter 2 R Objects (I): Vectors In this chapter, we focus on the most fundamental R object type: vectors. We will introduce different vector types, creating vectors with patterns, applying different functions and operations on vectors, comparing and extracting vectors. We will also discuss data and times, factors, and how R represents unexpected results. "],["vector.html", "2.1 Vectors: Numeric, Character, and Logical", " 2.1 Vectors: Numeric, Character, and Logical In the last chapter, you have had a basic understanding of R objects and how to do object assignments. From this section, we will start to introduce the first and perhaps the most fundamental R object type, called vector. Vector is the simplest object type in R, which contains one or more values of the same type. We will introduce numeric vector, character vector, and logical vector in this section. Let’s begin with numeric vector. 2.1.1 Numeric vector a. Create numeric vectors A numeric vector is a type of vector that only contains values of numeric type. For example, 6 is a numeric vector with one element of value 6. For vectors, the number of elements corresponds to the length of vector, so 6 is a numeric vector with length 1. After assigning the value 6 to the name x1, you have created a new vector x1 with the same value as 6, so x1 is also a numeric vector. And you can refer to x1 in the subsequent calculations. 6 #a numeric vector with length 1 x1 &lt;- 6 #x1 is also a numeric vector with length 1 x1 #check the value of x1 But can a numeric vector contain more than one values? The answer is a big YES! In R, you can use the c() function (c is short for combine) to combine elements into a numeric vector. c(1, 3, 3, 5, 5) #use c() to combine elements into a numeric vector of length 5 y1 &lt;- c(1, 3, 3, 5, 5) #y1 is also a numeric vector of length 5 y1 #check the value of y1 length(y1) #length of a vector In this example, you have created a length-5 object using the c() function with arguments containing the five elements separated by comma. Since the value of each element is a number, the object is a numeric vector. If you assign the values to the name y1, you will get a new numeric vector y1 with 5 values. Notice that the second and third elements have the same value 3 in y1. You can verify the contents of y1 and check the length of it through the length() function. When you assign several values to a name, the order of the values will not change after assignment. If you create two numeric vectors with same numbers of different orders, these objects will have different values. For example, y2 &lt;- c(1, 3, 5, 7, 9) y2 y3 &lt;- c(9, 7, 5, 3, 1) y3 Here, y2 and y3 have different values. If you include several numeric vectors in c(), you will also create a numeric vector as a combination of the input numeric vectors. For example, you can create a numeric vector with values from two numeric vectors. Of course you can create a new numeric vector z1 using object assignment. c(c(1,2), c(3,4)) #use c() to combine several numeric vectors into one numeric vector z1 &lt;- c(c(1,2), c(3,4)) z1 length(z1) After creating vectors, you can use the function class() to check its class. class(x1) #&gt; [1] &quot;numeric&quot; class(y1) #&gt; [1] &quot;numeric&quot; class(z1) #&gt; [1] &quot;numeric&quot; From the results, you will know that x1, y1 and z1 are numeric, which is the reason why they are called numeric vectors. b. Operations between two numeric vectors Since numeric vectors are made of numbers, you can do arithmetic operations between them, just like the fancy calculator in Section 1.2. If two vectors are of the same length, the calculation is done elementwisely. In other words, R will perform the operation separately for each element. First, let’s create another vector x2 of length 1 and do addition with x1. x2 &lt;- 3 x1 + x2 #&gt; [1] 9 Then obviously you will get 9! Similarly, you can create another vector y2 of the same length as vector y1. Then, you can do operations between y1 and y2. y2 &lt;- c(2, 4, 1, 3, 2) y1 + y2 #&gt; [1] 3 7 4 8 7 The result is yet another length-5 vector. To check the calculation was indeed done elementwisely, you can verify that the value of the first element is \\(1 + 2 = 3\\), and value of the second element is \\(3 + 4 = 7\\), etc. Since the calculation is done elementwisely, people normally would want the two vectors to have the same length. However, there is a recycling rule in R, which is sometimes quite useful and enables us to write simpler code. Specifically, if one vector is shorter than the other vector, R will recycle (repeat) the shorter vector until it matches in length with the longer one. This recycling is particularly helpful for an operator between a length&gt;1 vector and a length-1 vector. Let’s see an example. y1 + x1 #&gt; [1] 7 9 9 11 11 From the result, you can see that each element in y1 is added by 6. The followings are a few additional examples you can try. y1 * x2 y1 / 5 y2 - x1 2.1.2 Character vector a. Create character vectors Now, let’s move to character vectors. In a character vector, the value of each element is of character type, which means each value is a string. A string is a sequence of characters (including letters, numbers, or symbols) surrounded by a pair of double quotes (\"\") or single quotes (''). To be consistent, we will stick with double quotes in this book. Let’s first create a character vector sheepstudio which only has one element. You can then check the value of this vector by typing its name and verify the vector type by using class(). sheepstudio &lt;- &quot;sheep@007&quot; sheepstudio class(sheepstudio) Double quotes need to be paired in strings. If you miss the right double quote, R will show a plus on the next line, waiting for you to finish the command. If this happens, you can either enter the matching double quote, or press ESC to escape this command. Figure 2.1: Miss the right quotation mark Similar to a numeric vector, you can use the c() function to combine several strings to create a character vector. You can verify the number of strings in the character vector by using length(), and nchar() can help you get the number of characters in each string. animals &lt;- c(&quot;sheep@29&quot;, &quot;pig$29&quot;, &quot;monkey&quot;) animals length(animals) nchar(animals) Note that if you have a vector consisted of numbers with surrounding double quotes, it is also a character vector. (“4” and “29” are strings) num_vec &lt;- c(4, 29) char_vec &lt;- c(&quot;4&quot;, &quot;29&quot;) class(num_vec) #&gt; [1] &quot;numeric&quot; class(char_vec) #&gt; [1] &quot;character&quot; b. Concatenate several strings into a single string Next, we will introduce how to concatenate several strings into a single string. To do this, you can use the paste() function. First, let’s create a character vector with four elements, four_strings &lt;- c(&quot;This&quot;, &quot;is&quot;, &quot;Sheep@29&quot;, &quot;$Studio&quot;) length(four_strings) #verify the number of strings Then use paste() instead of c(), one_long_string &lt;- paste(&quot;This&quot;, &quot;is&quot;, &quot;Sheep@29&quot;, &quot;$Studio&quot;) one_long_string #&gt; [1] &quot;This is Sheep@29 $Studio&quot; class(one_long_string) length(one_long_string) #verify the number of strings From the results, you can see that one_long_string is a character vector with length 1, and the value of one_long_string is a single string with space between the individual strings. You may notice that in paste(), the default separator between the individual strings is space. Actually you can change the separator by setting the sep argument in paste(). For example, you can separate the individual strings with comma, comma &lt;- paste(&quot;This&quot;, &quot;is&quot;, &quot;Sheep@29&quot;, &quot;$Studio&quot;, sep = &quot;,&quot;) comma #&gt; [1] &quot;This,is,Sheep@29,$Studio&quot; If you don’t want to use a separator, you can use the paste0() function. nosep &lt;- paste0(&quot;This&quot;, &quot;is&quot;, &quot;Sheep@29&quot;, &quot;$Studio&quot;) nosep #&gt; [1] &quot;ThisisSheep@29$Studio&quot; If you would like to concatenate the strings of a vector into a longer string, you need to specify the collapse argument as the separator instead of sep in the paste() function. paste(four_strings, collapse = &quot;&quot;) #&gt; [1] &quot;ThisisSheep@29$Studio&quot; paste(four_strings, collapse = &quot;,&quot;) #&gt; [1] &quot;This,is,Sheep@29,$Studio&quot; paste(four_strings) ##doesn&#39;t work without the collapse argument #&gt; [1] &quot;This&quot; &quot;is&quot; &quot;Sheep@29&quot; &quot;$Studio&quot; In addition to paste several strings into one long string, you can also use the paste() function paste two character vectors, where the pair of strings will be pasted elementwisely. Month_vec &lt;- c(&quot;July&quot;, &quot;August&quot;) Year_vec &lt;- c(&quot;2007&quot;, &quot;2008&quot;) paste(Month_vec, Year_vec) #&gt; [1] &quot;July 2007&quot; &quot;August 2008&quot; c. Change case In character vectors, each string can contain both uppercase and lowercase letters. You can unify the cases of all letters inside a vector. Let’s review the character vector four_strings at first, four_strings &lt;- c(&quot;This&quot;, &quot;is&quot;, &quot;Sheep@29&quot;, &quot;$Studio&quot;) four_strings #&gt; [1] &quot;This&quot; &quot;is&quot; &quot;Sheep@29&quot; &quot;$Studio&quot; Then use the tolower() function to convert all letters to lower case, tolower(four_strings) #&gt; [1] &quot;this&quot; &quot;is&quot; &quot;sheep@29&quot; &quot;$studio&quot; The opposite function of tolower() is toupper(), which converts all letters to upper case, toupper(four_strings) #&gt; [1] &quot;THIS&quot; &quot;IS&quot; &quot;SHEEP@29&quot; &quot;$STUDIO&quot; 2.1.3 Logical vector So far we have created several numeric vectors and character vectors. Some vectors have names, and some do not. You can see all the named objects by using the ls() function. ls() #&gt; [1] &quot;a&quot; &quot;ani_char&quot; #&gt; [3] &quot;animal&quot; &quot;animal_tidy&quot; #&gt; [5] &quot;animal_wide&quot; &quot;animal_wide_weight&quot; #&gt; [7] &quot;animals&quot; &quot;b&quot; #&gt; [9] &quot;char_mat&quot; &quot;char_vec&quot; #&gt; [11] &quot;Code&quot; &quot;comma&quot; #&gt; [13] &quot;contributors&quot; &quot;d&quot; #&gt; [15] &quot;data_type&quot; &quot;dig_num&quot; #&gt; [17] &quot;dig_num_new&quot; &quot;Dim&quot; #&gt; [19] &quot;Explanation&quot; &quot;four_strings&quot; #&gt; [21] &quot;key_mat&quot; &quot;Keys&quot; #&gt; [23] &quot;m1&quot; &quot;m2&quot; #&gt; [25] &quot;Month_vec&quot; &quot;my_list&quot; #&gt; [27] &quot;my_vec&quot; &quot;n&quot; #&gt; [29] &quot;Name&quot; &quot;norm_dat&quot; #&gt; [31] &quot;norm_dat_1&quot; &quot;norm_dat_2&quot; #&gt; [33] &quot;norm_dat_3&quot; &quot;nosep&quot; #&gt; [35] &quot;num_vec&quot; &quot;one_long_string&quot; #&gt; [37] &quot;Operation&quot; &quot;p&quot; #&gt; [39] &quot;para_1&quot; &quot;para_2&quot; #&gt; [41] &quot;Pattern&quot; &quot;q&quot; #&gt; [43] &quot;Section&quot; &quot;sheepstudio&quot; #&gt; [45] &quot;Type&quot; &quot;w&quot; #&gt; [47] &quot;weight&quot; &quot;x&quot; #&gt; [49] &quot;x_numeric&quot; &quot;x1&quot; #&gt; [51] &quot;x2&quot; &quot;x3&quot; #&gt; [53] &quot;y_numeric&quot; &quot;y1&quot; #&gt; [55] &quot;y2&quot; &quot;y3&quot; #&gt; [57] &quot;year&quot; &quot;Year_vec&quot; #&gt; [59] &quot;z&quot; &quot;z1&quot; As introduced in Section 1.3, another way to check the named objects is via the environment panel as shown in Figure 2.2. Figure 2.2: Environment We can see that the environment panel has two columns, with the first column showing the list of object names, and the second column showing the corresponding information for each object. The information includes the vector type (chr is short for character and num is short for numeric), the vector length, and the first few values of the vector. Note that if the vector is of length 1 (for example x1), the environment will not show the type or the length. By now you have created several objects, and you will find that the objects will not be saved in R if you don’t assign their values to names, for example, the results of x1 + x2 and y1 + y2 are not shown in the environment. Before introducing the logical vector, let’s first learn a function called is.numeric(), which checks whether a vector is of numeric type, is.numeric(y1) #Is y1 of numeric type? #&gt; [1] TRUE Similar to is.numeric(), you can also use is.character() function to check if the given vector is of character type. is.character(y1) #Is y1 of character type? #&gt; [1] FALSE You may notice that results are TRUE or FALSE from the above codes. Actually, logical vectors are vectors that only use TRUE or FALSE as values. Note that TRUE and FALSE are logical constants in R. Similarly, you can use is.logical() to check if the vector is of logical type, or you can use class() to find out the exact type. logic1 &lt;- c(TRUE, FALSE, TRUE) #you can also use the c() function to create a logical vector is.logical(logic1) class(logic1) You can also use T to represent TRUE and F to represent FALSE in logical vectors. logic2 &lt;- c(T, F, F) is.logical(logic2) class(logic2) It is worth to point out that you don’t want to put a pair of double quotes around TRUE or FALSE when you use them as logical values. If you do that, a character vector will be generated instead. char &lt;- c(&quot;TRUE&quot;, &quot;FALSE&quot;, &quot;TRUE&quot;) is.logical(char) class(char) Note that the keywords TRUE and FALSE are case sensitive, and all letters inside them need to be in upper case. If you change any letter to the lower case, you will get an error, because True is neither a logical constant nor a defined object. tlogic &lt;- True #&gt; Error in eval(expr, envir, enclos): object &#39;True&#39; not found 2.1.4 Exercises Write R code to create a numeric vector named vec_1 with values 7 24 8 26, get its length, and find out its type. Write R code to create a character vector named char_1 with values \"I\", \"am\", \"learning\", \"R!\", get its length, find out its type, and concatenate the vector into a single string with space as the separator. For the char_1 defined in Q2, find the number of characters in each string, and convert each string to upper case. Create a length-2 logical vector representing whether vec_1 and char_1 are of character type. "],["attr-coercion.html", "2.2 Vectors: Storage Types, Attributes and Coercion", " 2.2 Vectors: Storage Types, Attributes and Coercion Having learned vectors in Section 2.1, we first introduce an important concept called storage types and use two commonly used numeric classes (integers and doubles) as examples, then introduce the concept of attributes from a named vector, and discuss the coercion rule when you combine values of different types into a single vector. 2.2.1 Storage Types Having learned the numeric vector, character vector, and logical vector, it is time to introduce how they are stored in R. To find the internal storage type of an R object, you can use the typeof() function. Let’s see an example of numeric vector. my_double &lt;- c(1, 3, 4) typeof(my_double) #storage type #&gt; [1] &quot;double&quot; class(my_num) #class #&gt; Error in eval(expr, envir, enclos): object &#39;my_num&#39; not found We can see that the internal storage type of my_num is double, which is stored as a double precision numeric value. Looking at the values of my_num, it is easy to see that they are all integers. You may be wondering it is necessary to store the integers in a double type. The answer is no. You can definitely store the integers in a integer type, which offers great memory savings compared to doubles. The tricky part is that you usually need to explicitly tell R that you are storing them as integers. To create an integer vector, you can still use the c() function with the integers separated by comma as arguments. However, you need to put an “L” after each integer. Let’s create an integer and check its typeof(). my_int &lt;- c(1L, 3L, 4L) typeof(my_int) #&gt; [1] &quot;integer&quot; class(my_int) #&gt; [1] &quot;integer&quot; You can see that my_int is indeed of integer type, with the class of it being integer as well. It is also worth noting that the displaying value of my_double and my_int are the same. my_double #&gt; [1] 1 3 4 my_int #&gt; [1] 1 3 4 In addition to class() and typeof(), another useful function is str(), which gives the detailed structure of an R object along with the first few values. Whenever we have an R object, it is useful to apply class(), typeof(), and str() on it. str(my_double) #&gt; num [1:3] 1 3 4 str(my_int) #&gt; int [1:3] 1 3 4 From the str() results, my_int is stored as integers while my_double is stored as double precision numeric values. Despite the differences between integers and doubles, you can usually ignore their differences unless you are working on a very big data set. R will automatically convert objects between integers and doubles when necessary. 2.2.2 Named Vectors and Attributes In addition to storing the values of a vector, you can also create named vectors. To do that, the first option is to give each element a name in the processing of creating the vector using the form of name = value. x_wo_name &lt;- c(165, 60, 22) x_wo_name #&gt; [1] 165 60 22 x_w_name &lt;- c(height = 165, weight = 60, BMI = 22) x_w_name #&gt; height weight BMI #&gt; 165 60 22 A second way to assign names to a vector is to use the names() function. For example, if we want to represent whether it snows on each day using a logical vector. y &lt;- c(TRUE, FALSE, TRUE) y #&gt; [1] TRUE FALSE TRUE names(y) &lt;- c(&quot;Jan 1&quot;, &quot;Jan 2&quot;, &quot;Jan 3&quot;) y #&gt; Jan 1 Jan 2 Jan 3 #&gt; TRUE FALSE TRUE Note that the assignment operation looks similar to the object assignment operation. The values for names need to be a character vector. The names of a vector is a type of attributes of R Objects. We will introduce other types of attributes as we encounter them. The name attribute provides additional information regarding the meaning of each element, and enables us to extract values using the names (to be discussed in Section 2.6.3). To examine the attributes of an R object, you can use the attributes() function. The str() also displays the attributes. attributes(x_w_name) #&gt; $names #&gt; [1] &quot;height&quot; &quot;weight&quot; &quot;BMI&quot; str(x_w_name) #&gt; Named num [1:3] 165 60 22 #&gt; - attr(*, &quot;names&quot;)= chr [1:3] &quot;height&quot; &quot;weight&quot; &quot;BMI&quot; str(x_wo_name) #&gt; num [1:3] 165 60 22 You can see that x_w_name is a named numeric vector, with the names attribute. In contrast, str() function tells us x_wo_name is a plain numeric vector with no attributes. To directly extract certain attributes of an R object, you can use the attr() function on it with the second argument being the specific attribute you wish to extract. attr(x_w_name, &quot;names&quot;) #&gt; [1] &quot;height&quot; &quot;weight&quot; &quot;BMI&quot; 2.2.3 The Coercion Rule So far, you know that vectors are objects that have values of the same type, including numeric values (integers or doubles), strings, or logical values. But in practice, you may have values with a mix of different types. If you still want to combine them into a vector, R will unify all values into the most complex one, which is usually called the coercion rule. Specifically, R uses the following order of complexity (from simple to complex). \\[\\mbox{logical} &lt; \\mbox{numeric} &lt; \\mbox{character}\\] Let’s see a few examples to learn how the coercion works. The first example mixes logical values with numbers. mix_1 &lt;- c(TRUE, 7, 24, FALSE) mix_1 #&gt; [1] 1 7 24 0 typeof(mix_1) #&gt; [1] &quot;double&quot; class(mix_1) #&gt; [1] &quot;numeric&quot; You can see that the logical values are converted to numbers, in particular, TRUE will be converted to 1 and FALSE will be converted to 0 when they appear with numbers, that’s because numbers are more complex than logical values, and R will unify all values into the most complex one. Then you will see that mix_1 is a numeric vector with four numbers. This is the most commonly usage of coercion rule in R. Besides the coercion rule which automatically converts all elements into the most complex type, you can also use functions to do the conversion manually. In particular, as.numeric() converts its argument into numeric type. And as.logical() converts its argument into logical values. as.numeric(c(TRUE, FALSE)) #&gt; [1] 1 0 as.logical(c(1, 0)) #&gt; [1] TRUE FALSE as.logical(c(&quot;TRUE&quot;, &quot;FALSE&quot;)) #&gt; [1] TRUE FALSE The second example mixes numbers with strings. mix_2 &lt;- c(8, &quot;happy&quot;, 26, &quot;string&quot;) mix_2 #&gt; [1] &quot;8&quot; &quot;happy&quot; &quot;26&quot; &quot;string&quot; class(mix_2) #&gt; [1] &quot;character&quot; You can see that both 8 and 26 are converted into strings since strings are more complex than numbers. Then mix_2 will be a character vector. To manually converts an input into a character type, you can use the as.character() function. as.character(1:5) #&gt; [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; The next example mixes logical values, numbers and strings. mix_3 &lt;- c(16, TRUE, &quot;pig&quot;) mix_3 #&gt; [1] &quot;16&quot; &quot;TRUE&quot; &quot;pig&quot; class(mix_3) #&gt; [1] &quot;character&quot; You can see in mix_3, both 97 and TRUE are converted to strings! That’s because values of character type are the most complex among all values. Here, you can use as.character() on the logical values. as.character(c(TRUE, FALSE)) #&gt; [1] &quot;TRUE&quot; &quot;FALSE&quot; Next, let’s see an interesting example in which we have two layers of coercion. mix_4 &lt;- c(c(16, TRUE), &quot;pig&quot;) mix_4 #&gt; [1] &quot;16&quot; &quot;1&quot; &quot;pig&quot; However, if you create another vector mix_4, you first have c(16, TRUE) which will be converted to c(16, 1) since numbers are more complex than logical values. Then, c(16, 1) will be converted to c(\"16\", \"1\") when you combine it with \"pig\", leading to the results of mix_4. Lastly, let’s talk about the coercion within numeric values. In particular, we have learned that there are two kinds of types numeric values are stored: namely integers and doubles. In the coercion rule, we have \\[\\mbox{integer} &lt; \\mbox{double}.\\] Let’s see the following examples. typeof(c(1, 5L)) #&gt; [1] &quot;double&quot; typeof(c(TRUE, 5L)) #&gt; [1] &quot;integer&quot; Let’s now summarize the coercion rule of all types we have learned. \\[\\mbox{logical} &lt; \\mbox{integer} &lt; \\mbox{double} &lt; \\mbox{character}\\] 2.2.4 Complex Vectors Another vector classes in R is complex, which stores complex numbers. my_complex &lt;- c(1 + 2i, 3 + 4i, -3 - 4i) my_complex #&gt; [1] 1+2i 3+4i -3-4i class(my_complex) #&gt; [1] &quot;complex&quot; typeof(my_complex) #&gt; [1] &quot;complex&quot; str(my_complex) #&gt; cplx [1:3] 1+2i 3+4i -3-4i You can use the functions Re(), Im(), and Mod() to get the real part, imaginary part, and the modulus of the complex vector, respectively. Re(my_complex) #&gt; [1] 1 3 -3 Im(my_complex) #&gt; [1] 2 4 -4 Mod(my_complex) #&gt; [1] 2.236068 5.000000 5.000000 2.2.5 Exercises If there are 3 lions, 5 tigers, 7 birds and 2 monkeys in the zoo, please write R code to create a named numeric vector zoo1 to clarify this situation. "],["vector-patterns.html", "2.3 Create Vectors with Patterns", " 2.3 Create Vectors with Patterns Now you are familiar with numeric vector, character vector and logical vector, and you can create them from scratch using the c() function. However, in many applications, we may want to create vectors with values of certain patterns. In this section, we will introduce several commonly used functions for generating vectors with patterns. 2.3.1 Create equally-spaced numeric vectors via : One of the commonly used patterns associated with numeric vectors is numeric vectors composed of equally-spaced integers, where the differences between adjacent values in the vectors are all \\(1\\) or \\(-1\\). Suppose we want to create a vector with consecutive integers from 1 to 5. The first method is to write all numbers down in c(), pattern1 &lt;- c(1, 2, 3, 4, 5) You can see that it is not too cumbersome to enumerate all 5 integers when creating pattern1. Let’s imagine if we want to create a vector containing 100 consecutive integers. Do we have a faster way than writing all 100 integers down? The answer is Yes! You can use the colon operator :, which is frequently used in everyday programming. (Note that you don’t need to use c() together with :) pattern2 &lt;- 1:5 #consecutive integers from 1 to 5 In addition to creating vectors with consecutive integers that is increasing, : can also be used to create vectors with integers in decreasing sequences. pattern3 &lt;- 6:2 #decreasing sequence from 6 to 2 pattern4 &lt;- 3:-3 #decreasing sequence from 3 to -3 Powerful the : operator is, it can only generate equally-spaced numeric vectors with increment 1 or -1. If you want to generate equally-spaced numeric vectors with different increments, you can use the more powerful seq() function. 2.3.2 Create equally-spaced numeric vectors via seq() A very efficient way to create equally-spaced numeric vectors is to use the seq() function, which is short for sequence. a. Create sequences with by argument To use the seq() function, you can specify the start value of the sequence in the from argument, the limit end value in the to argument, and the increment in the by argument. seq(from = 1, to = 5, by = 1) Here, the vector starts with 1, increases by 1 at each step, and ends at 5. Note that the from and by arguments are optional in seq(). If you don’t specify their values, seq() will use the default value 1 for both arguments. seq(to = 5) Now you have had four methods to create vectors with consecutive integers. c(1,2,3,4,5,6) #write all numbers down 1:6 #use colon operator seq(from = 1, to = 6, by = 1) #use seq() seq(to = 6) #use seq() Next, let’s change the increment to 2 and you will get a numeric vector with 1 3 5 as its values. seq(from = 1, to = 5, by = 2) #&gt; [1] 1 3 5 Note that the end value of the sequence doesn’t always equal the to argument. If you change the limit end value to 6, you still get the same sequence, since the next value in the sequence would be 7 which is larger than the limit end value 6. This is the reason why to is called the limited end value, not the end value. seq(from = 1, to = 6, by = 2) #&gt; [1] 1 3 5 Unlike :, you can set values of three arguments in seq() as decimal numbers. seq(from = 1.1, to = 6.2, by = 0.7) #&gt; [1] 1.1 1.8 2.5 3.2 3.9 4.6 5.3 6.0 Here, you will get a sequence which starts with 1.1, increases by 0.7 each time until it is larger than 6.2. You can also create a decreasing sequence by using a smaller to value than the from value, coupled with a negative value in the by argument. seq(from = 1.5, to = -1, by = -0.5) If a positive value is used in the by argument in a decreasing sequence, you will see an error message. seq(from = 1.5, to = -1, by = 0.5) #&gt; Error in seq.default(from = 1.5, to = -1, by = 0.5): wrong sign in &#39;by&#39; argument b. Create sequences with length.out argument Instead of setting the increment, you can also specify the length.out argument, which creates a sequence with equal space in the specified length. R will automatically calculate the interval between two neighboring numbers according to values of three arguments in seq(). seq(from = 1, to = 5, length.out = 9) Here, you will get a equally-spaced sequence of length 9 from 1 to 5. You can also create a decreasing sequence by using the length.out argument. seq(from = 5, to = -5, length.out = 9) Unlike creating sequences with by argument, if you specify the length.out argument in seq(), the start value and end value of the sequence you get will be exactly match the input arguments. c. Create sequences with both by and length.out arguments Lastly, if you provide both the by and length.out arguments, only one of from and to is needed. With one value (the start value or the limit end value) fixed, seq() will create a vector with specified increment and length. If you only have the from argument, you will get a sequence starting from the value you set with the increment in the by argument, until you get a sequence with specified length. seq(from = 1, by = 2, length.out = 5) If you only have the to argument, you will get a sequence end with the value you set with the increment in the by argument, until you get a sequence with specified length. seq(to = 1, by = 2, length.out = 5) One last thing regarding seq() is that you can at most provide three arguments. For example, you will see an error when running the following example since all four arguments are specified. seq(from = 1, to = 3, by = 1, length.out = 3) #&gt; Error in seq.default(from = 1, to = 3, by = 1, length.out = 3): too many arguments 2.3.3 Create matching numeric vectors via seq_along() Now, we will introduce one function related to seq(). Let’s first create a numeric vector, extend &lt;- seq(from = 2, to = 8, length.out = 9) From the seq() above, you know that the length of this vector is 9. Next, let’s put this numeric vector in seq_along(). seq_along(extend) #&gt; [1] 1 2 3 4 5 6 7 8 9 seq_along() takes a vector as its argument, and generates consecutive integers from 1 to the length of the input vector. The seq_along() function is commonly used when writing loops, which will be covered at a later time. You can also use 1:length(extend) to get the same result as seq_along(extend). 1:length(extend) 2.3.4 Create numeric vectors via sequence() Sometimes, you may want to combine multiple equally-spaced integer sequences into a single vector. To do this, you can use the function sequence(). The most common usage of sequence() is to supply a vector of integers as its input. comp_seq1 &lt;- sequence(c(2, 3, 5)) comp_seq1 #&gt; [1] 1 2 1 2 3 1 2 3 4 5 From the result, you can see that it firstly create equally-spaced vectors 1:2, 1:3, and 1:5, then combine all vectors into a single one. This avoids the trouble of writing something like c(1:2, 1:3, 1:5). More generally, we can construct a vector composed of more complex integer sequences with additional arguments, namely sequence(nvec, from, by). Here, the nvec , from and by are integer vectors of the corresponding length.out, from, and by arguments of each equally-spaced sequence. Let’s see the following example. comp_seq2 &lt;- sequence(nvec = c(4, 3, 2), from = c(1, 2, -1), by = c(2, -1, 2)) #&gt; Error in sequence(nvec = c(4, 3, 2), from = c(1, 2, -1), by = c(2, -1, : unused arguments (from = c(1, 2, -1), by = c(2, -1, 2)) comp_seq2 #&gt; Error in eval(expr, envir, enclos): object &#39;comp_seq2&#39; not found Now, sequence() generate three different equally-spaced integer sequences and combine them to a single vector. We can reproduce the vector using c() and three calls of the seq() function. comp_seq3 &lt;- c(seq(from = 1, by = 2, length.out = 4), seq(from = 2, by = -1, length.out = 3), seq(from = -1, by = 2, length.out = 2)) comp_seq3 #&gt; [1] 1 3 5 7 2 1 0 -1 1 2.3.5 Create numeric, character and logical vectors with repetition Another commonly used pattern associated with vectors is repetition. Note that while the equally-spaced pattern only makes sense for numeric vectors, the repetition pattern work for all three kinds of vectors. To do repetition, you can use the rep() function, which works by repeating the first argument for the number of times indicated in the second argument. Firstly, let’s create a numeric vector with repetition. num1 &lt;- rep(2, 4) num1 #&gt; [1] 2 2 2 2 Since the first argument is 2 and the second argument is 4, 2 is repeated for 4 times, resulting a length-4 vector with all elements of value 2. The first argument can also be a numeric vector with several values. num2 &lt;- rep(c(1, 4, 2), 3) num2 #&gt; [1] 1 4 2 1 4 2 1 4 2 Here, the rep() will repeat the whole vector c(1, 4, 2) three times. Note that the vector is repeated as a whole, not elementwisely. You may be wondering what happens the second argument also has several numbers? Let’s try together. num3 &lt;- rep(c(1,5,7), c(3,2,1)) num3 #&gt; [1] 1 1 1 5 5 7 When the second argument is also a vector, R will do an element repeat operation by repeating each element in the first argument the number of times indicated in the corresponding location of the second argument, and combine the repeated vectors to a single vector. In this example, 1 is repeated 3 times, 4 is repeated twice, and 7 is repeated once. It is equivalent to c(rep(1,3), rep(4,2), rep(7,1)) The rep() function works the same way if the first argument is a character vector. animals1 &lt;- rep(c(&quot;sheep&quot;, &quot;pig&quot;, &quot;monkey&quot;), 2) animals1 animals2 &lt;- rep(c(&quot;sheep&quot;, &quot;pig&quot;, &quot;monkey&quot;), c(3, 2, 1)) animals2 You can also use logical vectors in the first argument. logic &lt;- rep(c(TRUE, FALSE), c(3,2)) logic 2.3.6 Getting unique elements and their frequencies So far, you have learned how to create vectors with different patterns. Sometimes, you may want to get the unique elements (elements of different values) of a vector and their corresponding frequencies. Let’s use num3 as an example. (Don’t forget to use ls() or check the environment panel to find all objects you have defined), num3 #check the values #&gt; [1] 1 1 1 5 5 7 You can use unique() to show all unique elements in vectors. unique(num3) #get the unique elements #&gt; [1] 1 5 7 From the result, you know the unique elements in num3 are 1,5, and 7. To get the frequency of each element, you can use the table() function. table(num3) #get the frequency table #&gt; num3 #&gt; 1 5 7 #&gt; 3 2 1 Here, the first row is the name of the object, the second row shows all unique elements, and the third row is the corresponding frequency of each element in the same column. In num3, there are three 1s, two 5s and one 7. unique() and table() work similarly for character vectors and logical vectors. You can try the following codes. animals unique(animals) table(animals) logic unique(logic) table(logic) 2.3.7 Exercises Use five different ways to create an equally-spaced sequence with 2 4 6 8 10 as result. Use two different ways to create a numeric vector with 1 2 3 1 2 3 4 5 1 2 3 4 5 6 7 as result. Show the unique elements and their corresponding frequency. Write R code using rep() function to create a character vector with the same result as c(\"sheep\",\"pig\", \"cat\",\"sheep\",\"pig\", \"cat\",\"sheep\",\"pig\", \"cat\") Write R code using rep() function to create character vector with the same result as c(\"sheep\",\"sheep\",\"pig\",\"pig\",\"pig\",\"pig\",\"cat\",\"cat\",\"cat\") "],["sort-vector.html", "2.4 Sort, Rank, &amp; Order", " 2.4 Sort, Rank, &amp; Order In the past two sections, you have mastered how to create vectors of different types including numeric, character and logical. In addition, you know how to create vectors with patterns. A vector usually contains more than one elements. Sometimes, you want to order the elements in various ways. In this section, we will introduce important functions that relate to ordering elements in a vector. 2.4.1 Numeric vectors Let’s start with numeric vectors. Firstly, let’s create a numeric vector which will be used throughout this part. x &lt;- c(2, 3, 2, 0, 4, 7) x #check the value of x a. Sort vectors The first function we will introduce is sort(). By default, the sort() function sorts elements in vector in the ascending order, namely from the smallest to largest. sort(x) #&gt; [1] 0 2 2 3 4 7 If you want to sort the vector in the descending order, namely from the largest to smallest, you can set a second argument decreasing = TRUE. sort(x, decreasing = TRUE) b. Ranks of vectors Next, let’s talk about ranks. The rank() function gives the ranks for each element of the vector, namely the corresponding positions in the ascending order. rank(x) #&gt; [1] 2.5 4.0 2.5 1.0 5.0 6.0 If you check the values of x, you can see that the smallest value of x is 0, which corresponds to the fourth element. Thus, the fourth element has rank 1. The second smallest value of x is 2, which is shared at the first and the third elements, resulting a tie (elements with the same value will result in a tie). Normally, these two elements would have ranks 2 and 3. To break the tie, the rank() function assigns all the elements involving in the tie (the first and third elements in this example) the same rank, which is average of all their ranks (the average of 2 and 3), by default. In addition to this default behavior for handling ties, rank() also provides other options by setting the ties.method argument. If you set ties.method = \"min\", all the tied elements will have the minimum rank instead of the average rank. In this case, the minimum rank is 2. rank(x, ties.method = &quot;min&quot;) #&gt; [1] 2 4 2 1 5 6 If you want to break the ties by the order element appears in the vector, you can set ties.method = \"first\". Then the earlier appearing element will have smaller ranks than the later one. In this example, the first element will have rank 2 and the third element has rank 3, since the first element appears earlier than the third element. There are other options for handling ties, which you can look up in the documentation of rank() if interested. rank(x, ties.method = &quot;first&quot;) #&gt; [1] 2 4 3 1 5 6 Unlike sort(), you can’t get positions in the descending order from the rank() function, which means you can’t add decreasing = TRUE in rank(). c. Order of vectors The next item we want to introduce is the order() function. Note that the function name order could be a bit misleading since ordering elements also has the same meaning of sorting. However, although it is related to sorting, order() is a very different function from sort(). Let’s recall the values of x and apply order() on x. x #&gt; [1] 2 3 2 0 4 7 order(x) #&gt; [1] 4 1 3 2 5 6 From the result, you can see that the order() function returns indices for the elements in the ascending order, namely from the smallest to the largest. For example, the first output is 4, indicating the 4th element in x is the smallest. The second output is 1, showing the 1st element in x is the second smallest. Unlike rank(), the order() function breaks the ties by the appearing order by default. If you want the indices corresponding to the descending order, then you can set decreasing = TRUE just like what we did in the sort() function. order(x, decreasing = TRUE) So far, we have covered sort(), rank() and order() functions for numeric vectors. It is helpful to provide a brief summary. The sort() function sorts elements in vectors. The rank() function will give ranks for each element of the vector. The order() function returns indices for the elements. 2.4.2 Character vectors Now, let’s move to character vectors. For character vectors, R uses the lexicographical ordering, which is sometimes called dictionary order since it is the order used in a dictionary. Similar to numeric vectors, let’s first prepare a character vector. Note that the strings in character vectors can contain letters, numbers, or symbols. char_vec &lt;- c(&quot;a&quot;, &quot;A&quot;, &quot;B&quot;, &quot;b&quot;, &quot;ab&quot;,&quot;aC&quot;, &quot;1c&quot;, &quot;.a&quot;, &quot;1a&quot;,&quot;2a&quot;,&quot;.a&quot;,&quot;&amp;u&quot;,&quot;3&quot;,&quot;_4&quot;) a. Ordering rules First, let’s discuss the ordering of a single character, including symbols, digits and letters. There are a few important ordering rules as follows. symbols &lt; digits &lt; letters: symbols appear first, followed by digits, and letters come last. symbols are ordered in the following way. syms &lt;- c(&quot; &quot;,&quot;,&quot;,&quot;;&quot;,&quot;_&quot;,&quot;(&quot;,&quot;)&quot;,&quot;!&quot;,&quot;[&quot;,&quot;]&quot;,&quot;{&quot;,&quot;}&quot;,&quot;-&quot;,&quot;*&quot;,&quot;/&quot;,&quot;#&quot;,&quot;$&quot;,&quot;%&quot;,&quot;^&quot;,&quot;&amp;&quot;,&quot;`&quot;,&quot;@&quot;,&quot;+&quot;,&quot;=&quot;,&quot;|&quot;,&quot;?&quot;,&quot;&lt;&quot;,&quot;&gt;&quot;,&quot;.&quot;) sort(syms) #&gt; [1] &quot; &quot; &quot;_&quot; &quot;-&quot; &quot;,&quot; &quot;;&quot; &quot;!&quot; &quot;?&quot; &quot;.&quot; &quot;(&quot; &quot;)&quot; &quot;[&quot; &quot;]&quot; &quot;{&quot; #&gt; [14] &quot;}&quot; &quot;@&quot; &quot;*&quot; &quot;/&quot; &quot;&amp;&quot; &quot;#&quot; &quot;%&quot; &quot;`&quot; &quot;^&quot; &quot;+&quot; &quot;&lt;&quot; &quot;=&quot; &quot;&gt;&quot; #&gt; [27] &quot;|&quot; &quot;$&quot; digits are in an ascending order: the smaller digits appear earlier than the bigger ones. nums &lt;- 0:9 sort(nums) #&gt; [1] 0 1 2 3 4 5 6 7 8 9 letters are alphabetically ordered, for the same letter，the lower case comes first. all_letters &lt;- c(letters,LETTERS) sort(all_letters) #&gt; [1] &quot;a&quot; &quot;A&quot; &quot;b&quot; &quot;B&quot; &quot;c&quot; &quot;C&quot; &quot;d&quot; &quot;D&quot; &quot;e&quot; &quot;E&quot; &quot;f&quot; &quot;F&quot; &quot;g&quot; #&gt; [14] &quot;G&quot; &quot;h&quot; &quot;H&quot; &quot;i&quot; &quot;I&quot; &quot;j&quot; &quot;J&quot; &quot;k&quot; &quot;K&quot; &quot;l&quot; &quot;L&quot; &quot;m&quot; &quot;M&quot; #&gt; [27] &quot;n&quot; &quot;N&quot; &quot;o&quot; &quot;O&quot; &quot;p&quot; &quot;P&quot; &quot;q&quot; &quot;Q&quot; &quot;r&quot; &quot;R&quot; &quot;s&quot; &quot;S&quot; &quot;t&quot; #&gt; [40] &quot;T&quot; &quot;u&quot; &quot;U&quot; &quot;v&quot; &quot;V&quot; &quot;w&quot; &quot;W&quot; &quot;x&quot; &quot;X&quot; &quot;y&quot; &quot;Y&quot; &quot;z&quot; &quot;Z&quot; Here, letters is a character vector pre-created by R, it has all 26 letters in the alphabet with lower case. And LETTERS is another character vector, which has all 26 letters in the alphabet with upper case. b. Sort vectors As before, you can apply sort() on character vectors. Basically, the elements of character vectors ordered by the first character of their values, move to the second character if there are ties in the first character (same first character), and look at more characters until the ties are broken or run out of characters. sort(char_vec) #&gt; [1] &quot;_4&quot; &quot;.a&quot; &quot;.a&quot; &quot;&amp;u&quot; &quot;1a&quot; &quot;1c&quot; &quot;2a&quot; &quot;3&quot; &quot;a&quot; &quot;A&quot; #&gt; [11] &quot;ab&quot; &quot;aC&quot; &quot;b&quot; &quot;B&quot; We have the following observations. Symbols appear first, followed by digits, and letters come last. According to the ordering rule of symbols, _4 is the first, .a should be the second and &amp;u is the third. 1a and 1c have the same first character, since a comes before c, 1a comes before 1c. ab and aC have the same first character, since b comes before C (regardless of the case), ab comes before aC. Of course, we can also have the order reversed by setting decreasing = TRUE. sort(char_vec, decreasing = TRUE) c. Ranks of vectors Similarly, you can look at the rank for each element according to the ordering rules. Here, the element with rank 1 is _4 and .a has rank 2. Just like numeric vectors, if you have elements with the same value in character vectors, the rank of these elements will be the same (the average of the corresponding ranks) by default. rank(char_vec) #&gt; [1] 9.0 10.0 14.0 13.0 11.0 12.0 6.0 2.5 5.0 7.0 #&gt; [11] 2.5 4.0 8.0 1.0 As expected, you can set the ties.method argument in rank() to use other methods for breaking ties. rank(char_vec, ties.method = &quot;min&quot;) rank(char_vec, ties.method = &quot;first&quot;) d. Order of vectors Again, you can get the indices for each element in character vectors with the same order() function like that for numeric vectors. Also, the order() function breaks the ties by the appearing order by default. order(char_vec) #&gt; [1] 14 8 11 12 9 7 10 13 1 2 5 6 4 3 The decreasing argument still works for order()! order(char_vec, decreasing = TRUE) #&gt; [1] 3 4 6 5 2 1 13 10 7 9 12 8 11 14 2.4.3 Logical vectors Since there are only two possible values TRUE and FALSE for logical vectors, it is straightforward to sort them with the knowledge of FALSE &lt; TRUE. You can try the following example. logi_vec &lt;- c(TRUE, FALSE, FALSE, TRUE, TRUE) sort(logi_vec) rank(logi_vec) order(logi_vec) 2.4.4 Exercises Write R codes to solve the following problems. Create a numeric vector named exe with values 2, 0, -3, 0, 5, 6 and sort exe from the largest to the smallest. In exe, what’s the ranks of 2 and the first 0? For exe, get indices for the elements in the ascending order. Create a character vector with values \"&amp;5\", \"Nd\", \"9iC\", \"3df\", \"df\", \"nd\", \"_5\", \"9ic\" and sort it in the ascending order. Then, explain 1) why 3df goes before 9ic; 2) why &amp;5 goes before 3df; 3) why 9ic goes before 9iC. "],["vector-functions.html", "2.5 Statistical Functions on Vectors", " 2.5 Statistical Functions on Vectors In this section, we will continue talking about functions on vectors, and focus on various statistical functions. 2.5.1 Numeric vectors Let’s first create a numeric vector. h &lt;- c(3, 2, 75, 0, 100) h #check the value of h Next, we will divide statistical functions into several groups, and introduce them one by one. Group A: minimum and maximum min(h) max(h) range(h) First, you can get the minimum and maximum values of a numeric vector, and range() produces a length-2 vector with both the minimum value(the first element) and maximum value(the second element). which.min(h) which.max(h) In addition to getting the minimum and the maximum values, it is often useful to get the corresponding locations of them. Here, the fourth element in h has the minimum value 0, so you will get a result of 4 from which.min(). If there are multiple elements with the minimum value, which.min() will return the first location. Similarly, which.max() tells you the location of the maximum value. g &lt;- c(2, 2, 1, 1) which.min(g) which.max(g) The third element and the fourth element in g both have the minimum value, but which.min(g) has a value of 3 since the third element is the first location with the minimum value. Similarly, which.max() gives you a result of 1. cummin(h) cummax(h) In addition to calculating the minimum value of all elements, you can also use the cumulative minimum function, called cummin(). It returns a vector of the same length as the input vector, with the value at each location being the minimum of all preceding elements until that location in the original vector. For example, the first element of cummin(h) is 3 since the minimum of the first element in the original vector is always itself, the second element is 2 since the minimum of the first two elements (3 and 2) in his 2, and so on. Note that once we reach the minimum value of the vector, the remaining elements of the cumulative minimum function will always equal to the minimum value. There is also a corresponding function for computing the cumulative maximums, called cummax(). Group B: sum and product sum(h) cumsum(h) Next, let’s look at the sum() function, which produces the sum of all elements in the vector. For the numeric vector h, the sum is 3+2+75+0+100, which is 180. Similar to cummin(), you can use the cumsum() function to compute the cumulative sums, which works by summing up the elements of the original vector cumulatively up to each location. In cumsum(h), the first element is 3 since there is only one element to do summation, the second element is 5 since the summation of the first two elements (3 and 2) in h is 5, and you can easily verify the value of the remaining elements by yourself. prod(h) cumprod(h) We also have the prod() function, computing the product of all elements of h. Since there is 0 in h, the result is 0. Again, we have the cumulative product function cumprod() working by multiplying the elements of the original vector cumulatively up to each location. Group C: mean and median sort(h) #&gt; [1] 0 2 3 75 100 Before introducing this group, let’s first review the sort() function introduced in Section 2.4. By default, this function can sort elements from the smallest to the largest. mean(h) median(h) The mean() function returns the average of all elements. And the median() function returns the middle number in the resulting vector of sort() where the elements are listed in order from the smallest to the largest. If the vector length is odd, the middle number is the value of the element in the central location. In sort(h), we can see that the median corresponds to the third number out of five numbers since there are two numbers larger than 3 and two numbers smaller than 3. If the vector length is even, the middle number is the average of the two middle elements after sorting. sort(g) median(g) Take g for example, after sorting, you will see that 1 and 2 are in the middle. The median is then defined as the average of these two elements, equaling 1.5. Group D: quantiles quantile(h) #&gt; 0% 25% 50% 75% 100% #&gt; 0 2 3 75 100 quantile() produces sample quantiles of a given numeric vector. By default, it generates 5 numbers, the top row represents the different percentiles, including the 0 percentile, 25th percentile (0.25 quantile), 50th percentile (0.5 quantile), 75th percentile (0.75 quantile), and 100th percentile, and the second row consists of the corresponding values of each quantile. We next go over all five quantile values. First of all, 0 percentile and 100th percentile are always the minimum and the maximum values, respectively. The 50th percentile (0.5 quantile) is the same as the median. The 25-th percentile (0.25 quantile), also called the first quartile, is the value such that there are 25 percent (or a quarter) of the remaining data (whole data without this number) smaller than it. For vector h, the value is 2 since there is exactly 1 number, which is 25 percent of the remaining 4 numbers, smaller than 2. Similarly, the 75-th percentile, also called the third quartile, is the value such that 75 percent of the remaining data is smaller than this number. For vector h, the value is 75 since there are 3 numbers, which are 75 percent of the remaining 4 numbers, smaller than 75. You also have an important concept called interquartile range (IQR), defined as the difference between the 3rd quartile (75-th percentile) and the 1st quartile (25-th percentile). The interquartile range of h is 73, which is 75 - 2. IQR(h) In addition to the default five percentiles, you can also use the quantile() function to get any quantile between 0 and 1. To do this, you just need to specify the second argument probs. Let’s try to find the 95th quantile. quantile(h, probs = 0.95) As before, this asks you to compute the 95th percentile, meaning 95 percent of the remaining data is smaller than this value. Because you only have 5 values in this vector, it may not be very intuitive. However, if you have more elements in a vector, say 1001, you can count the number of the remaining data that is smaller than this value, which should be 950 (the number of remaining data is 1000, and 95 percent of 1000 is 950). In addition, the second argument can be a vector of probabilities, which will produce a numeric vector of the corresponding quantiles. quantile(h, probs = c(0.1, 0.2, 0.99)) Group E: summary statistics summary(h) #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. #&gt; 0 2 3 36 75 100 Compared with quantile(), a more general function to have a comprehensive understanding of numeric vectors is summary(). From summary(), you can get the 5 percentiles and the mean. (Min: 0 percentile, 1st Qu: 25-th percentile, Median: 50-th percentile, 3rd Qu: 75-th percentile, Max: 100-th percentile) Group F: variance and standard deviation var(h) sd(h) The last group of functions are var() and sd() which compute the sample variance and sample standard deviation of a numeric vector, respectively. The formula of sample variance of vector \\(h\\) is \\[var(h) = \\frac{1}{n-1}\\sum_{i=1}^n (h_i-\\bar h)^2,\\] where \\(n\\) is the length of \\(h\\) and \\(\\bar h\\) is the average of all elements. By definition, the sample standard deviation is the square root of sample variance, which you can verify by sqrt(var(h)). For your convenience, we would like to provide a summary of all the functions introduced in the following table. Operation Explanation min(h) the minimum value max(h) the maximum value range(h) both the minimum value and the maximum value which.min(h) the (first) location of the minimum value which.max(h) the (first) location of the maximum value cummin(h) the cumulative minimum values cummax(h) the cumulative maximum values sum(h) the sum of all elements cumsum(h) the cumulative sum prod(h) the product of all elements cumprod(h) the cumulative products mean(h) the average of all elements median(h) the middle number in sort(h) quantile(h) the 0 percentile, 25-th percentile, 50-th percentile, 75-th percentile, and 100-th percentile IQR(h) the difference between the 3rd quartile and the 1st quartile quantile(h, probs = 0.95) the 95-th percentile quantile(h, probs = c(0.1, 0.2, 0.99)) several quantiles at a time summary(h) 5 percentiles and the mean var(h) the sample variance sd(h) the sample standard deviation 2.5.2 Character vectors Compared with numeric vectors, there are much less things you can do on character vectors. For character vectors, you can also apply summary(). animals &lt;- rep(c(&quot;sheep&quot;, &quot;pig&quot;, &quot;monkey&quot;), 3:1) summary(animals) From the result, you can see that the summary() function will only tell you the vector length (6 elements) and vector type (character vector), much less useful than the case for numeric vectors. 2.5.3 Logical vectors What if we apply summary() on logical vectors? logic &lt;- rep(c(T,F,T), 3:1) summary(logic) Similar to character vectors, you can get the vector type, which is logical here. You also get a frequency table for the times FALSE and TRUE appear in the vector. Different from character vectors, you can apply almost all the functions summarized in Table ?? to logical vectors, where the coercion rule introduced in Section 2.2.3 will be in effect to convert all logical values into numerical values. In particular, in the logical vector, TRUE will be converted to 1 and FALSE will be converted to 0. Let’s take a look at an example, a &lt;- c(TRUE, TRUE, FALSE, FALSE, TRUE) sum(a) mean(a) Clearly, sum(a) equals 3 since there are 3 TRUE values and mean(a) equals 0.6 since it is the average of three 1s and two 0s. You are welcome to try other functions on a logical vector. 2.5.4 Exercises Suppose x &lt;- c(5, 2, 4, 1, 2, 1), y &lt;- c(T, F, F, F, F, T, T, F, F, T) Write R code to reproduce each element of the summary vector summary(x) Write R code to generate the cumulative sum, cumulative product, cumulative minimum, and cumulative maximum of x. Write R code to generate a vector consisting of the 0.1, 0.2, 0.6, 0.8, 0.9 quantiles of x. Write R code to calculate the sample variance and sample standard deviation of x. Write R code to generate a length-2 vector consisting of the sum and mean of y. Then show the unique elements of y and their corresponding frequencies. "],["comparison-vector-subsetting.html", "2.6 Comparisons, Vector Subsetting &amp; Change Values", " 2.6 Comparisons, Vector Subsetting &amp; Change Values By now, you are more than familiar with the simplest type of R objects—vector, and you can create vectors and apply many useful functions on vectors. Sometimes you may be wondering how to extract certain elements from a vector? In this section, we will introduce some new operations on vectors that can help you get the desired subvector. 2.6.1 Comparisons on vectors of the same type The first type of operations we want to introduce is making comparisons between two vectors of the same type. Similar to the arithmetic operations between two numeric vectors in Section 2.1, we normally want to compare two vectors of the same length, but we can also compare two vectors of different lengths according to the recycling rule in R. a. Compare two vectors of the same length If two vectors are of the same length, the comparison is done elementwisely, just like the arithmetic operations in Section 2.1. Let’s take numeric vectors for example. You can create a numeric vector x with value 3, and compare it to another numeric vector 2 to find out whether the value of x is smaller than 2 or not. x &lt;- 3 x &lt; 2 #&gt; [1] FALSE Since 3 is bigger than 2, you will certainly get FALSE! In addition to the less than sign &lt;, there are a few other commonly useful operators for doing comparisons. x &lt; 2 #less x &lt;= 2 #less or equal to x &gt; 1 #bigger x &gt;= 1 #bigger or equal to x == 3 #equal to #x = 3 #assignment operator x != 3 #not equal to Note that if you want to check whether two vectors are equal, you have to use two equal signs as a single operator, which is ==, to do comparisons. If only one equal sign is used, it would work like an assignment operator. In addition, you can use an exclamation mark together with a equal sign, which is !=, to find out whether two vectors are not equal. Note that as we explained in Section 1.3.2, sometimes you need to execute an R expression because you can get its object type and value from the result. Here, you may notice that you get TRUE or FALSE as the result from the codes above. Since TRUE and FALSE are logical values (there are no pairs of double quotes around TRUE’s and FALSE’s when you use them as logical values), you know that all comparison operations generate logical vectors. Of course, you can assign the result to a name for future use. Let’s take x &gt; 1 for example. class(x &gt; 1) length(x &gt; 1) big1 &lt;- x &gt; 1 big1 class(big1) So x &gt; 1 and big1 are both logical vectors with length one. Also, you can create two length&gt;1 numeric vectors y and z with the same length, then do comparisons between them. y &lt;- c(3,5,7,5,3) z &lt;- c(2,6,7,6,3) y &gt; z #&gt; [1] TRUE FALSE FALSE FALSE FALSE From the result, you can see that y &gt; z is a length-5 logical vector. The values of y &gt; z are obtained by making elementwise comparisons between the corresponding elements in these two vectors. big2 &lt;- y &gt; z big2 class(big2) which(big2) By assigning y &gt; z to a big2, you create another logical vector. Here, the which() function returns the locations of all TRUE values, so you will get a result of 1 for big2. You can also compare two character vectors, which works by comparing the corresponding strings in the same location. The rule for comparison is the alphabetically order explained in Section 2.4.2. Similar to comparing numerical vectors, we also use two equal signs == to check whether the corresponding elements in the two input vectors have the same value. Let’s first create two character vectors with the same length, then use == to compare them. Since the expression of this comparison is again a logical vector, you can create a new logical vector same1 and get the locations of TRUE values. You can also use other comparison operators. animals &lt;- c(&quot;pig&quot;, &quot;monkey&quot;, &quot;pig&quot;) zoo &lt;- c(&quot;sheep&quot;, &quot;monkey&quot;, &quot;pig&quot;) same1 &lt;- animals == zoo which(same1) which(animals != zoo) Comparisons between logical vectors work similarly as character vectors, where we usually use == or != to compare corresponding elements in logical vectors. Here are some examples. logi1 &lt;- c(TRUE, FALSE, FALSE) logi2 &lt;- c(TRUE, TRUE, TRUE) same2 &lt;- logi1 == logi2 which(same2) which(logi1 != logi2) b. Compare between one vector with length &gt; 1 and another vector with length 1 The recycling rule also works for the comparison operations in R. With an vector of length 1, you can compare the value of it to the values of another vector with more than one elements one by one, which generates a logical vector. The length of the logical vector will be the same as that of the longer vector. Here are some examples. y != x animals == &quot;pig&quot; logi1 == TRUE 2.6.2 Comparisons on vectors of different types When you try to compare two vectors of different types, the coercion rule in Section 2.2.3 will apply. In particular, values of corresponding elements will be unified into the more complex one when making comparisons between two vectors. The order of complexity from simple to complex is still \\(\\mbox{logical} &lt; \\mbox{integer} &lt; \\mbox{double} &lt; \\mbox{character}\\). Let’s try to compare between a numeric vector and a logical vector, a &lt;- c(-1, 0, 1) b &lt;- c(TRUE, FALSE, TRUE) a == b #&gt; [1] FALSE TRUE TRUE Then you will get a length-3 logical vector. In a == b, the first element is obtained by using == to compare -1 and TRUE, then R will convert TRUE to 1 and make comparison between -1 and 1 since numbers are more complex than logical values. The second and third elements are also obtained in a similar fashion. This is the most common use of comparisons between vectors of different types. You can make comparisons between vectors of other types, the following example shows that the classic transitive property in math (\\(a=b\\) and \\(b=c\\) imply \\(a=c\\)) doesn’t hold in R. 1 == TRUE #&gt; [1] TRUE TRUE == &quot;TRUE&quot; #&gt; [1] TRUE 1 == &quot;TRUE&quot; #&gt; [1] FALSE 2.6.3 Vector subsetting Sometimes you may want to extract particular elements from a vector, then the extracted elements will constitute a new vector, which is a subvector of the original vector. This process is called vector subsetting, and the subvector will be of the same type as the original one. In this part, we will introduce two common ways to do vector subsetting in R. Before we get started, let’s create a vector which will be used throughout this part. h &lt;- c(3,1,4,2,90) a. Use logical vectors to do vector subsetting Firstly, we introduce how to use logical vectors to do vector subsettings. You need to use a pair of square brackets [ ] after a vector, then put a logical vector of the same length as the original vector inside the square brackets. Here is an example, h[c(TRUE, FALSE, TRUE, FALSE, TRUE)] #&gt; [1] 3 4 90 From the result, you can see that the values from h with the same positions of TRUEs are extracted. Since 3, 4 and 90 are parts of the values of h, the vector composed of 3 4 90 is a subvector of h. When assigning these three values to a name, you will get a named subvector sub1. sub1 &lt;- h[c(TRUE, FALSE, TRUE, FALSE, TRUE)] sub1 #&gt; [1] 3 4 90 In addition to writing the logical vector in an explicit form, you can also use a named logical vector or an expression whose result is a logical vector. Let’s say we want to find the subvector of h for all elements in h that are larger than 2. Then, you can first compare h with 2, getting a logical vector. big3 &lt;- h &gt; 2 big3 #&gt; [1] TRUE FALSE TRUE FALSE TRUE Then you may notice that both big3 and h &gt; 2 are identical to c(TRUE, FALSE, TRUE, FALSE, TRUE). So naturally you can also put big3 or h &gt; 2 into [ ], which generates the same subvector with 3 4 90 as values. h[c(TRUE, FALSE, TRUE, FALSE, TRUE)] h[big3] h[h &gt; 2] If you create a character vector home and compare it to \"pig\", you will get another logical vector same3. Let’s try to use same3 to do vector subsetting on h. home &lt;- c(&quot;pig&quot;, &quot;monkey&quot;, &quot;pig&quot;, &quot;monkey&quot;, &quot;pig&quot;) same3 &lt;- home == &quot;pig&quot; sub2 &lt;- h[same3] sub2 #&gt; [1] 3 4 90 Awesome! You still get the result of 3 4 90! As a result, as long as the logical vectors you use have the same values, you will get the same result after doing vector subsetting. Of course, you can do vector subsetting on character vectors or logical vectors. Keep in mind that the result will be the same type as the original one. Try the following code by yourself. home[same3] home[big3] lg &lt;- c(TRUE, FALSE, FALSE, FALSE, TRUE) lg[same3] lg[big3] b. Use indices to do vector subsetting Next, we will introduce how to use indices to do vector subsetting. To achieve this goal, you need to put a numeric vector inside [ ], for example, h[c(2,4)] #return values of the 2nd and 4th elements of h #&gt; [1] 1 2 You get values of the 2nd and 4th elements in h. If you add a minus sign - before the numeric vector, you will get all elements except the 2nd and 4th ones in h. h[-c(2,4)] #return values except the 2nd and 4th elements of h #&gt; [1] 3 4 90 Similar to using a named logical vectors, you can also use a named numeric vector to do vector subsetting. indices &lt;- c(2,4) sub3 &lt;- h[indices] sub3 Also, you can get subvectors of character vectors or logical vectors using indices. home[indices] lg[indices] In conclusion, there are two ways to get a subvector of h with values bigger than 2. h &lt;- c(3,1,4,2,90) h[h &gt; 2] #h &gt; 2 will return TRUE if the element in h has value bigger than 2 h[c(1,3,5)] #It&#39;s clear to see that the first, third and fifth elements have values bigger than 2 c. using names to do vector subsetting For a named vector, we can also use character vector consisting of the names as indices to do vector subsetting. x_w_name &lt;- c(height = 165, weight = 60, BMI = 22) x_w_name[&quot;height&quot;] #&gt; height #&gt; 165 x_w_name[c(&quot;weight&quot;, &quot;BMI&quot;)] #&gt; weight BMI #&gt; 60 22 2.6.4 Change values in named vectors a. Change all values in subsets of vectors Now you must be curious about why do we need to get subsets of vectors. Firstly let’s review values of vector h and get a subset of it. (There are two ways to do vector subsetting, here we choose to use indices to get the subset) h &lt;- c(3,1,4,2,90) h[c(2,4)] Obviously you will get a numeric vector with 1 and 2 as the values. Let’s see how to change values just for a subset of h, which is actually a very important usage of doing vector subsetting. You just need to assign new values to the subset, then you can verify the values of h. Let’s see an example, h[c(2,4)] &lt;- 10 h #&gt; [1] 3 10 4 10 90 From the result, you can see that only 1 and 2 have been changed to 10, which means you have successfully change parts of h! b. Define the vector again Another way to change values in named vectors is to do object assignment again on this vector, then you can change all values of it without changing the name. In Section 1.3, you have learned about checking all the named objects and their values in the environment. So let’s review values of vector h from this panel together. Figure 2.3: Values of h (1) Now we all know that h is a numeric vector with 5 values. Then let’s try to do an object assignment again, this time you can assign different values to h and see what will happen to h. h &lt;- c(1,2,3,4,5) h #&gt; [1] 1 2 3 4 5 Then you can see that the values of h have been changed to the new ones! Another easier way to verify values of h is from the environment, so it is a good habit to monitor the environment from time to time to make sure everything look fine. Figure 2.4: Values of h (2) You can assign any values to h as you want, then h may change the vector type or even the object type according to the values assigned. By running the following code, h will be a character vector with three strings. h &lt;- c(&quot;pig&quot;, &quot;monkey&quot;, &quot;panda&quot;) Figure 2.5: Values of h (3) If you assign values of a subvector to a name, you will create a new named vector. Now hs is not the subset of h, it is a vector with the same value as the subset. If you assign different value(s) to hs, there will be no change on h. h &lt;- c(3,1,4,2,90) hs &lt;- h[c(2,4)] hs &lt;- 10 h 2.6.5 Exercises Consider the vector v1 &lt;- c(7, 2, 4, 9, 7), v2 &lt;- c(6, 2, 8, 7, 9), and v3 &lt;- 1:50. Find the locations in v1 where the corresponding value is smaller than v2. Find the subvector of v2 such that the corresponding location in v1 is larger than 5. Find the subvector of v3 such that it is divisible by 7. (Hint: the result of 7%%7 is equal to 0 since 7 is divisible by 7) For all elements of v3 that is divisible by 8, replace it by 100. "],["logical-operators.html", "2.7 Logical Operators", " 2.7 Logical Operators In last section, you learned how to do vector subsetting, which yields a subvector of the original vector. Let’s take a numeric vector x &lt;- 1:5 for example. In order to get a subvector of x with values bigger than 3, you can first create a logical vector xb3 &lt;- x &gt; 3, then use the xb3 as the index to do vector subsetting. x &lt;- 1:5 xb3 &lt;- x &gt; 3 set1 &lt;- x[xb3] set1 #&gt; [1] 4 5 Here, the numeric vector set1 has values 4 5. You can get another subvector of x by running the following codes. xs4 &lt;- x &lt;= 4 set2 &lt;- x[xs4] Sometimes, you may want to get a subvector with more than one conditions. For example, how can we find the subvector of x with values larger than 3 and less than or equal to 4? In this section, we will introduce several logical operators and use them to get subvectors. Here, we only introduce how to apply these operators on logical vectors. Before we get started, let’s create another numeric vector y and compare it to 8 and 9 separately, then you will get two logical vectors with same values as xb3 and xs4. y &lt;- 6:10 yb8 &lt;- y &gt; 8 #xb3 is the same as yb8 ys9 &lt;- y &lt;= 9 #xs4 is the same as ys9 2.7.1 NOT operator by ! The first operator we want to introduce is !, often called the NOT operator. Let’s see what happens if you apply the NOT operator on a logical vector, !c(FALSE, FALSE, FALSE, TRUE, TRUE) #the opposite of a logical vector #&gt; [1] TRUE TRUE TRUE FALSE FALSE From the result, you get another logical vector with the same length as the original one. The value of each element in the new vector is the opposite of the corresponding value in the original vector. It is intuitive to understand since if something is NOT FALSE, then it is TRUE; and if it is NOT TRUE, then it has to be FALSE. Since xb3 is also a logical vector, you can try to apply ! on xb3, and use !xb3 (which is also a logical vector) to do vector subsetting. Guess what will you get? !xb3 #&gt; [1] TRUE TRUE TRUE FALSE FALSE set3 &lt;- x[!xb3] set3 #&gt; [1] 1 2 3 Of course the resulting numeric vector set3 will have 1 2 3 as values! As a result, set1 and set3 are complement of each other from the whole vector x. From Section 2.6, you have learned that if the logical vectors you use are identical, you will get the same result after doing vector subsetting. So if you use !yb8 to do vector subsetting, you will get a vector with the same result as that when you use set3. x[!yb8] #&gt; [1] 1 2 3 2.7.2 AND operator by &amp; Secondly, we will introduce the AND operator &amp;. Similar to making comparisons between two logical vectors, &amp; performs comparisons elementwisely, which generates a vector with the same length if the input logical vectors are of the same length or with the same length as that of the longer vector. For each location of the resulting vector, the value will be TRUE if both values in the same location of the input two vectors are both TRUE, and will be FALSE otherwise. In particular, for each element, we have the following summary. Operation Result TRUE &amp; TRUE TRUE TRUE &amp; FALSE FALSE FALSE &amp; TRUE FALSE FALSE &amp; FALSE FALSE Let’s see an example of the AND operation between two logical vectors of the same length. c(FALSE, FALSE, FALSE, TRUE, TRUE) &amp; c(TRUE, TRUE, FALSE, TRUE, FALSE) #&gt; [1] FALSE FALSE FALSE TRUE FALSE As explained before, the AND operator works elementwisely and the intermediate step is as below. c(FALSE &amp; TRUE, FALSE &amp; TRUE, FALSE &amp; FALSE, TRUE &amp; TRUE, TRUE &amp; FALSE) #&gt; [1] FALSE FALSE FALSE TRUE FALSE As you can see from the result, only the fourth element is TRUE since the fourth element of both input logical vectors is TRUE. Since the AND operator makes comparisons elementwisely, the recycling rule also works here. But normally we want one vector with length &gt; 1 and another one with length 1. c(FALSE, FALSE, FALSE, TRUE, TRUE) &amp; FALSE #&gt; [1] FALSE FALSE FALSE FALSE FALSE After learning about the AND operator, you can now get a subvector of x with value(s) &gt; 3 and &lt;= 4 easily. At the beginning of this section, you have created two logical vectors xb3 and xs4 by making comparisons, then let’s apply &amp; on these vectors, xb3 &amp; xs4 #&gt; [1] FALSE FALSE FALSE TRUE FALSE From the result, you know that both xb3 and xs4 have value TRUE for the fourth element, which means the statement that the value is &gt; 3 and &lt;= 4 is TRUE for the fourth element in x. Then you can use xb3 &amp; xs4 (a logical vector) to do vector subsetting. x[xb3 &amp; xs4] #&gt; [1] 4 Here, you get a subvector of x with value 4. Since xs4 and ys9 have same values, you will get the same result if you include ys9 to get a subvector. You can try the following codes by yourself. x[xb3 &amp; ys9] x[yb8 &amp; ys9] Note that the logical vector used to do vector subsetting needs to be of the same length as the original vector. Since x and y have the same length, the logical vectors from above can be used to get subvectors of y as well. You will get the same result from the following four codes. y[xb3 &amp; xs4] y[yb8 &amp; ys9] y[xb3 &amp; ys9] y[yb8 &amp; xs4] 2.7.3 OR operator by | The OR operator | works similarly to the AND operator &amp;, but the difference is that | returns TRUE if there is at least one TRUE among the two elements at the same location in two vectors. Let’s go through some examples together. Operation Result TRUE | TRUE TRUE TRUE | FALSE TRUE FALSE | TRUE TRUE FALSE | FALSE FALSE Let’s try another example on length &gt; 1 vectors and compare the result with that when we use the AND operator &amp;. c(FALSE, FALSE, FALSE, TRUE, TRUE) | c(TRUE, TRUE, FALSE, TRUE, FALSE) #&gt; [1] TRUE TRUE FALSE TRUE TRUE c(FALSE, FALSE, FALSE, TRUE, TRUE) &amp; c(TRUE, TRUE, FALSE, TRUE, FALSE) #&gt; [1] FALSE FALSE FALSE TRUE FALSE You also get a length-5 logical vector with an elementwise OR operation |, which is very different from the result with AND operation &amp;. Of course you can also use xb3 | xs4 to do vector subsetting, with it being another length-5 logical vector. x[xb3 | xs4] #&gt; [1] 1 2 3 4 5 Wow! You get all five elements of x! That’s because the statement “the value is either &gt; 3 or &lt;= 4” is TRUE for all elements in x. 2.7.4 Exclusive OR by xor Last but not least, we introduce the exclusive OR operator xor. From the name, it’s easy to know that xor is an extended form of |. Here are some examples, Operation Result xor(TRUE, TRUE) FALSE xor(TRUE, FALSE) TRUE xor(FALSE, TRUE) TRUE xor(FALSE, FALSE) FALSE Different from the OR operator, xor() returns TRUE when there is one and only one TRUE among values of these two logical vectors. If these two vectors have the same value, both TRUE or both FALSE, you will get the value FALSE. For two length &gt; 1 vectors, xor() again performs comparisons elementwisely. You can check the result by yourself! xor(c(FALSE, FALSE, FALSE, TRUE, TRUE), c(TRUE, TRUE, TRUE, TRUE, FALSE)) #&gt; [1] TRUE TRUE TRUE FALSE TRUE Since you also get a logical vector after applying xor(), you can use it to do vector subsetting. Using different combinations to do vector subsetting is interesting. Try them! x[xor(xb3, xs4)] y[xor(!xb3, ys9)] y[xor(yb8, !ys9)] 2.7.5 Summary of Logical Operators Let’s summarize the logical operators between two vectors. The NOT operator ! gives the opposite of each value. The AND operator &amp; returns TRUE if both are TRUE. The OR operator | returns TRUE if at least one is TRUE. The exclusive OR operator xor() returns TRUE if one and only one is TRUE. 2.7.6 Exercises Consider the vector v1 &lt;- seq(from = 1, to = 100, by = 3), and v2 &lt;- sqrt(v1). Find the subvector of v1 with values bigger or equal to 30 and less than 60. And assign the subvector to name v1s. Find the subvector of v2 such that the corresponding value of v1 is less than 20 or larger than 50. Use an example to verify \\(xor(a, b) = (!a &amp; b) | (a &amp; !b)\\) "],["set-operations-between-two-vectors.html", "2.8 Set Operations between two vectors", " 2.8 Set Operations between two vectors In Section 2.7, we introduced logical operators which are operators between two logical vectors. In this section, we will discuss set operations between two vectors of the same type. Note that while the logical operators only make sense for logical vectors, the operations we will introduce work for all three kinds of vectors. In the rest of this section, we will introduce several operations one by one. 2.8.1 Numeric vectors Let’s start with numeric vectors. Firstly, let’s create two numeric vectors x and y. x &lt;- c(1, 2, 1, 3, 1) y &lt;- c(1, 1, 3, 4, 4, 5) a. Intersection To get values in both x and y, you can use the intersect() function. intersect(x, y) #&gt; [1] 1 3 Note that although x has three elements of 1 and y has two, the result of their intersection only has one 1, showing that only the unique elements are retained in the output. b. Union To get values in either x or y, you can use the union() function. union(x, y) #&gt; [1] 1 2 3 4 5 Again, only one copy of each value is retained in the output. c. Set difference To get values in x but not in y, you can use the setdiff() function. Notice that x is in the first argument and y is in the second in this situation. setdiff(x, y) #&gt; [1] 2 Then you will get the result of 2! But you may be wondering why you don’t get 1 2 as the result since there is one more 1 in x than in y? That’s because for this operation, you will get unique elements of x and y firstly, then find the set difference between them. Similarly, if you want to get values in y but not in x, y should be in the first argument and x is in the second. setdiff(y, x) #&gt; [1] 4 5 d. Set equality To check whether the two vectors x and y are the same, you can use the setequal() function. setequal(x, y) #&gt; [1] FALSE Of course you will get FALSE since x has value 2 which y doesn’t have. Similar to the setdiff() function, the setequal() function works by looking at whether the two vectors have same set of unique values. For example, you will get TRUE in the following example, setequal(c(1, 1, 2), c(1, 2)) #&gt; [1] TRUE e. Membership determination To check whether each element of x is inside y, you can use the is.element() function or the %in% operator. is.element(x, y) #&gt; [1] TRUE FALSE TRUE TRUE TRUE x %in% y #&gt; [1] TRUE FALSE TRUE TRUE TRUE In this example, it returns a logical vector of length-5, the same length as x. The first element of x is 1, and y also has elements with value 1, so the first element of the logical vector is TRUE. The second element of x is 2, but y doesn’t have any elements with value 2, hence the result is FALSE. You can verify the other elements by yourself. The order of vectors is important for membership determination since if you put y before x, you will check whether each element of y is inside x. is.element(y, x) #&gt; [1] TRUE TRUE TRUE FALSE FALSE FALSE y %in% x #&gt; [1] TRUE TRUE TRUE FALSE FALSE FALSE Please find a summary of the set operations between x and y in the following table. Operation Code Intersection intersect(x, y) Union union(x, y) Set Difference setdiff(x, y) Set Equality setequal(x, y) Membership Determination is.element(x, y) 2.8.2 Character vectors Now you must have been familiar with all the five operations! Similar to numeric vectors, you can also apply operations on character vectors. Here are some codes which you can run by yourself. a &lt;- c(&quot;sheep&quot;, &quot;monkey&quot;, &quot;sheep&quot;, &quot;chicken&quot;, &quot;dragon&quot;) b &lt;- c(&quot;sheep&quot;, &quot;pig&quot;, &quot;pig&quot;) intersect(a, b) union(a, b) setdiff(a, b) setequal(a, b) a %in% b 2.8.3 Logical vectors Of course you can also apply set operations on logical vectors. c &lt;- c(&quot;T&quot;, &quot;F&quot;, &quot;F&quot;, &quot;T&quot;) d &lt;- c(&quot;T&quot;, &quot;T&quot;, &quot;T&quot;) intersect(c, d) union(c, d) setdiff(c, d) setequal(c, d) c %in% d 2.8.4 Exercises Consider the vector s1 &lt;- seq(from = 1, to = 100, length.out = 7). Compare s1 to 50 to see whether the values of s1 are bigger than 50, then assign the result to name s2. Compare s1 to 80 to see whether the values of s1 are less or equal to 80, then assign the result to name s3. Use two methods (logical operators and set operations) to find the subvector of s1 with values bigger than 50 and less or equal to 80. For x &lt;- 1:200, use two methods (logical operators and set operations) to find the subvector of x that is divisible by 7, but not divisible by 2. "],["summary-of-operators.html", "2.9 Summary of Operators", " 2.9 Summary of Operators Now we have fully introduced the first object—-vectors. You have learned how to create vectors and apply various operations on them. There are several different types of operators to conduct different operations in R. In this section, we want to give you a brief review of some operators and operations according to their types. Let’s summarize the four types of operators we have learned. In the following parts, we will review each type one by one. Operator Section arithmetic operator 1.2 assignment operator 1.3 relational operator 2.6 logical operator 2.7 2.9.1 Arithmetic operator Arithmetic operators (Section 1.2) are operators that often used to some basic calculations. The following is a list of operators available in R. Operator Explanation addition subtraction multiplication / division %/% integer division %% modulus ^ exponentiation 2.9.2 Assignment operator The assignment operator (Section 1.3) is the perhaps the most fundamental operator. It can help you to create objects with names. Operator Explanation &lt;- do object assignment 2.9.3 Relational operator Relational operators are operators that are often used to do comparisons. The following is a list of operators available in R. Operator Explanation &lt; less &lt;= less than or equal to &gt; bigger &gt;= bigger than or equal to == equal to != not equal to 2.9.4 Logical operator Logical operators are often used between two logical vectors when we want to do a particular vector subsetting. The following is a list of logical operators available in R. Operator Explanation ! NOT &amp; AND | OR xor() Exculsive OR In addition to using various operators to conduct operations, we can do much more using various functions in R. "],["na.html", "2.10 Missing Values (NA)", " 2.10 Missing Values (NA) In applications, you may encounter the situation where some values are missing in the data set. In this scenario, R uses NA to represent those values, indicating they are not available. Let’s see the following example. a &lt;- 1:10 a[11] #&gt; [1] NA Since you have defined a as a vector of length 10, there are 10 values in a. If you try to access the 11th element of a, it is not available, hence you will see NA as the result. Sometimes, the values of some elements in a vector are missing, then you can use NA for these elements. Here is an example containing NAs in values. If you want to get values of the 2nd and 4th elements in b, of course you will get NA NA as the result. b &lt;- c(1, NA, 2, NA, 3) b #&gt; [1] 1 NA 2 NA 3 b[c(2,4)] #&gt; [1] NA NA Now you have had a basic understanding of NA. In the following parts of this section, we want to introduce several properties of NA. Let’s start with NA is contagious. 2.10.1 NA is contagious NA implies that the underlying value is not available, in other words, there is uncertainty with the value. As a result, for most operations associated with NA, the results will also be NA, showing that NA is contagious. y &lt;- NA y + 3 #&gt; [1] NA y == 3 #&gt; [1] NA As you can see here, y is NA, indicating the value of y is not available. When you try to do operations like y + 3 or y == 3, the answers are clearly not available as well, hence both taking the value NA. How about we create another NA object and compare it with y? z &lt;- NA y == z #&gt; [1] NA It is again NA, which may be confusing at first. However, keep in mind that since both y and z are not available, there is no way to tell whether they are the same. Hence y == z is also NA. Think about what is the value of 1NA in R. Try to run it in R. Does it agree with your thoughts? Think about what is the value of 0NA in R. Try to run it in R. Does it agree with your thoughts? Answer 1. For any \\(x\\), we have \\(1^x = \\exp(\\log (1^x)) = \\exp(x \\log 1) = \\exp(x \\cdot 0) = 1\\). Since there is no uncertainty regarding the expression, the value of 1NA is 1 Answer 2. We have \\(0^0 = \\lim_{x\\to 0}x^x =\\exp[\\lim_{x\\to 0} x\\log(x)]=\\exp[0] = 1\\), and \\(0^1 = 0\\). Since NA represents uncertainty values, it can be 0 or 1 or other numbers. So 0NA is not deterministic because it can take different values according to the exponent. Hence, the value of 0NA is also NA. Now, let’s talk about what impact the NA values make when we apply statistical functions. Let’s create a vector containing NA values, and apply some functions on it. x &lt;- c(1, NA, 3, 4, NA, 2) x #&gt; [1] 1 NA 3 4 NA 2 sum(x) #&gt; [1] NA mean(x) #&gt; [1] NA sd(x) #&gt; [1] NA As you can see, for many statistical functions on vectors, as long as there exists at least one NA values in vectors, the results are often impossible to determine, hence resulting an NA value as well. As a result, you may want to ignore the NA values during the function evaluation. Fortunately, most statistical functions on vectors provide an optional argument na.rm, which takes a logical value, indicating whether to remove NA before applying the functions. Let’s see the following examples. sum(x, na.rm = TRUE) #&gt; [1] 10 mean(x, na.rm = TRUE) #&gt; [1] 2.5 sd(x, na.rm = TRUE) #&gt; [1] 1.290994 It is easy to verify that the results are what we expect to get if the NA values are removed. Feel free to try the following codes which apply the same functions on the subvector with the non-missing values. x_no_na &lt;- c(1, 3, 4, 2) sum(x_no_na) mean(x_no_na) sd(x_no_na) Interesting, the summary() function will deal with the NA values automatically by removing them before computing the five percentiles and the mean. In addition, the summary() function provides a column which shows the number of NAs in x. summary(x) #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s #&gt; 1.00 1.75 2.50 2.50 3.25 4.00 2 2.10.2 Work with NA values When there are NA values in our vector, there is nothing to be afraid of as there are many useful tools we can use. Let’s use x &lt;- c(1, NA, 3, 4, NA, 2) throughout this part. a. Find indices with missing values Firstly, we will introduce how to find indices with missing values. To find the indices, you may be tempted to use the comparison operator introduced in Section 2.6. Let’s try to compare x with NA as the following code. x == NA You get a vector of all values equaling NA! This is actually not surprising for the following reason. Given that the NA you are comparing can take any unknown value, any comparison with it will result in an NA value due to the lack of information. Instead of using == for finding missing values, the correct way is to use the is.na() function, which returns a logical vector x_na representing whether the value of each element is missing or not. Then, you can use the which() function which can return the locations of all TRUE values to find the indices for the NA values. Here, the sum() function on the logical vector x_na returns the number of NA values in the vector, following the cocercion rule described in Section 2.5.3. x_na &lt;- is.na(x) #logical vector x_na #&gt; [1] FALSE TRUE FALSE FALSE TRUE FALSE which(x_na) #numeric vector #&gt; [1] 2 5 sum(x_na) #the number of NAs in x #&gt; [1] 2 sum(!x_na) #the number of non-NAs in x #&gt; [1] 4 If you only want to detect whether there is any NA values in the vector, you can use the anyNA() function. anyNA(c(NA, 1)) #&gt; [1] TRUE anyNA(1:3) #&gt; [1] FALSE b. Remove missing values Sometimes, you may want to simply remove the missing values. To do that, you can use a logical vector to do vector subsetting as introduced in Section 2.6.3. The specific logical vector you want to use is the opposite (!) of the logical vector that represents missing values. Then you will get a subvector of x which keeps all values except NA. x2 &lt;- x[!x_na] x2 #&gt; [1] 1 3 4 2 c. Impute missing values In many applications, naively removing the missing values before doing the analysis may lead to incorrect inference. Usually, it is useful to make the data complete by imputing the missing values. For example, you can use mean imputing or median imputing, which replaces the missing values with the mean or median of the non-missing values. x_impute &lt;- x mean(x, na.rm = TRUE) #&gt; [1] 2.5 x_impute[x_na] &lt;- mean(x, na.rm = TRUE) x_impute #&gt; [1] 1.0 2.5 3.0 4.0 2.5 2.0 x #&gt; [1] 1 NA 3 4 NA 2 If you want to compare the values of an object before and after some operations, you can create a new object with the same value as the original object (here, we create x_impute which has the same value as x), then make operations on x_impute without changing the value of x. In x_impute, values of the 2nd and 5th elements are replaced by 2.5, the average of the non-missing values of x. d. Replace non-standard missing values with NA in the vector Sometimes, the data we collected may not use NA to indicate missingness. For example, in the following vector x3, the value 999 represents the corresponding element is missing. x3 &lt;- c(4, 999, 1, 999, 3, 999, 999) It is highly recommended to convert the values into NA before carrying out any analysis. x3[x3 == 999] &lt;- NA x3 #&gt; [1] 4 NA 1 NA 3 NA NA Let’s see another example where both 999 and -999 represent the value is missing. You can convert all 999 and -999 into NA by using operations introduced in Section 2.8.1 x4 &lt;- c(4, 999, 1, -999, 3, -999, 999) ##999 and -999 are the values indicating missingness x4[x4 %in% c(999, -999)] &lt;- NA x4 #&gt; [1] 4 NA 1 NA 3 NA NA 2.10.3 Exercises For the vector x &lt;- rep(c(1, 2, NA), 3:5), verify each value of summary(x) by using other functions. find the indices with missing values; create a vector x_no_na containing the non-missing values in x; replace those missing values by the median of the non-missing values in x. For the vector y &lt;- rep(c(\"N\", 2, \"A\"), 5:3), the values of both \"N\" and \"A\" indicate missingness. Convert non-standard missing values to NA, then find the indices of y that correspond to missing values. "],["factor.html", "2.11 Character Vectors, Factors &amp; Ordered Factors", " 2.11 Character Vectors, Factors &amp; Ordered Factors Having learned character vectors in Section 2.1.2, we introduce a very important data type in this section, named factors. First, let’s create a character vector to be used in this section. animals &lt;- c(&quot;sheep&quot;, &quot;pig&quot;, &quot;monkey&quot;, &quot;sheep&quot;, &quot;sheep&quot;, &quot;pig&quot;) 2.11.1 Create a factor from a vector So, what exactly is a factor? It can be viewed as a special type of vector whose elements take on a fixed and known set of different values. You can create a factor from a vector using the factor() function. To understand the output of a factor, it is helpful to compare the results with the original vector animals. animals_fac &lt;- factor(animals) animals_fac #&gt; [1] sheep pig monkey sheep sheep pig #&gt; Levels: monkey pig sheep animals #&gt; [1] &quot;sheep&quot; &quot;pig&quot; &quot;monkey&quot; &quot;sheep&quot; &quot;sheep&quot; &quot;pig&quot; First, note that the strings in the character vector all have quotation marks around the elements, while the corresponding factor doesn’t have them. Second, we see an additional row in the factor, starting with “Levels:” This shows the unique elements of animals ordered alphabetically. If you use the class() function on animals_fac, you will see it is indeed a factor. class(animals_fac) class(animals) To get a levels of a factor, you can use the function levels() on it. levels(animals_fac) #&gt; [1] &quot;monkey&quot; &quot;pig&quot; &quot;sheep&quot; To have deeper understanding on factors, it is helpful to check its internal storage type using typeof(). typeof(animals_fac) #&gt; [1] &quot;integer&quot; as.numeric(animals_fac) #&gt; [1] 3 2 1 3 3 2 Perhaps a bit surprisingly, a factor is stored as integers. The integers represent the corresponding locations of each element in the levels. For example, the first value of as.numeric(animals_fac) is 3, since the first element of animals_fac is \"sheep\", which is the third element in the levels. The particular storage mechanism for factors is very appealing in the sense that storing integers takes much less space than storing all the same levels repeatedly in the original character vector. As the same time, you can easily reproduce the original character vector using the integers and the factor levels using vector subsetting via indices. levels(animals_fac)[as.numeric(animals_fac)] #&gt; [1] &quot;sheep&quot; &quot;pig&quot; &quot;monkey&quot; &quot;sheep&quot; &quot;sheep&quot; &quot;pig&quot; To show that factors indeed could take less memory than the corresponding character vectors when the levels are repeated many times, let’s see the following example where we use the object.size() function to check the estimate of memory used to store the corresponding object. many_animals &lt;- rep(c(&quot;sheep&quot;, &quot;pig&quot;, &quot;monkey&quot;), c(100,200,300)) many_animals_fac &lt;- factor(many_animals) object.size(many_animals) #&gt; 5016 bytes object.size(many_animals_fac) #&gt; 3032 bytes From this example, we can see that storing the information as a factor could offer substantial memory savings (about 40% in this example) compare to storing it as a character vector. Another advantage of factors over vectors is that it will detect any input that is outside of the levels. Let’s try to assign the string “Tiger” to the first element of both animals_fac and animals. animals_fac[1] &lt;- &quot;Tiger&quot; animals_fac #&gt; [1] &lt;NA&gt; pig monkey sheep sheep pig #&gt; Levels: monkey pig sheep animals[1] &lt;- &quot;Tiger&quot; animals #&gt; [1] &quot;Tiger&quot; &quot;pig&quot; &quot;monkey&quot; &quot;sheep&quot; &quot;sheep&quot; &quot;pig&quot; Since \"Tiger\" is not inside the levels set, we see a warning in the assignment process and the value of the first element is changed to &lt;NA&gt;. When the same assignment is done on the vector animals, there is no warning and the first element of animals is changed to “Tigers” as instructed. This is an attractive feature of factors that can prevent input errors. In addition to creating factors from character vectors, you can also create them from numeric vectors as well as logical vectors. x &lt;- rep(3:1, 1:3) x_fac &lt;- factor(x) y &lt;- rep(c(T, F), c(5, 3)) y_fac &lt;- factor(y) It is worth noting that after we convert a numeric vector into a factor, the usual arithmetic operation can no longer be applied since the numbers become levels. x_fac[1] + 1 #&gt; Warning in Ops.factor(x_fac[1], 1): &#39;+&#39; not meaningful #&gt; for factors #&gt; [1] NA The result is NA with a warning message. 2.11.2 Set the factor levels and labels As we have seen, the factor() function extracts the unique elements from a vector and sort them as its levels. To manually specify the levels and their order, you can set the levels argument. For example, if you only want \"sheep\" and \"pig\" in the level, you can use the following code. factor(animals_fac, levels = c(&quot;pig&quot;, &quot;sheep&quot;)) #&gt; [1] &lt;NA&gt; pig &lt;NA&gt; sheep sheep pig #&gt; Levels: pig sheep As you can see, the third element becomes NA, since it corresponding element \"monkey\" in the original vector is not in the set of levels. You can also create labels to represent each level of the factor by setting the labels argument in the factor() function. factor(animals_fac, levels = c(&quot;pig&quot;, &quot;sheep&quot;), labels = c(&quot;pretty_pig&quot;, &quot;smart_sheep&quot;)) #&gt; [1] &lt;NA&gt; pretty_pig &lt;NA&gt; smart_sheep #&gt; [5] smart_sheep pretty_pig #&gt; Levels: pretty_pig smart_sheep An alternative way to change the levels of the levels is to assign the desired level vector to the levels() function with the factor as its argument. For example, if you want to translate the animals names into Spanish, you can use levels(animals_fac) &lt;- c(&quot;mona&quot;, &quot;cerda&quot;, &quot;oveja&quot;) animals_fac #&gt; [1] &lt;NA&gt; cerda mona oveja oveja cerda #&gt; Levels: mona cerda oveja 2.11.3 Ordered factors By default, the function factor() creates an unordered factor, which is usually used when there are no natural ordering among the levels. Sometimes, there may be a natural ordering among the levels. Let’s see an example. conditions &lt;- c(&quot;excellent&quot;, &quot;good&quot;, &quot;excellent&quot;, &quot;good&quot;, &quot;average&quot;) factor(conditions) Different from the animals in animals, the conditions have a natural ordering. We know \\(average &lt; good &lt; excellent\\). To reflect this in a factor, you can create an so-called ordered factor by setting ordered = TRUE and specify the levels in the ascending order of the desired ordering. condition_ordered_fac &lt;- factor(conditions, ordered = TRUE, levels = c(&quot;average&quot;, &quot;good&quot;, &quot;excellent&quot;)) condition_ordered_fac #&gt; [1] excellent good excellent good average #&gt; Levels: average &lt; good &lt; excellent We can see that there is an ordering shown in the “Levels.” You can also do comparisons on ordered factors. condition_ordered_fac[1] &lt; condition_ordered_fac[2] #&gt; [1] FALSE The result is FALSE since \\(excellent &gt; good\\). We will revisit the topic of factor ordering when generating bar charts in Section 4.10.2. 2.11.4 Exercises What are the advantages of factors over vectors? Suppose we define x &lt;- factor(1:5), what is the result of x[1] &lt; x[2]? Please try to answer this question without R. (a): TRUE (b): FALSE (c): NA Suppose we define x &lt;- factor(1:5, ordered = TRUE), what is the result of x[1] &lt; x[2]? Please try to answer this question without R. (a): TRUE (b): FALSE (c): NA Suppose we define x &lt;- factor(1:5, ordered = TRUE, levels = 5:1), what is the result of x[1] &lt; x[2]? Please try to answer this question without R. (a): TRUE (b): FALSE (c): NA Suppose size &lt;- rep(c(\"big\", \"small\", \"medium\"), 3:1), convert it to an ordered factor with levels small &lt; medium &lt; big. "]]
