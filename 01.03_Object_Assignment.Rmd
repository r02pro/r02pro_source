## Object Assignment {#Object-Assignment}

```{r, echo=FALSE}
rm(list=ls())
```

```{r, include=FALSE}
knitr::opts_chunk$set(
  comment = "#>", echo = TRUE, eval = TRUE, results = FALSE, error = TRUE, fig.width = 6, warning = FALSE, collapse = TRUE)
```

In the last section, you saw how R handles one-off calculations. To perform longer analyses, you usually need to keep the result of one step so it can be reused later.

Consider the following three calculations, each of which repeats the expression `exp(3) / log(20, 3) * 7`.

```{r}
(exp(3) / log(20, 3) * 7) + 3 #addition
(exp(3) / log(20, 3) * 7) - 3 #subtraction
(exp(3) / log(20, 3) * 7) / 3 #division
```

Typing the same expression three times is easy to mess up and hard to maintain. Object assignment lets you store that intermediate value once and reuse it wherever you need it.

### What is an R Object?

Before we talk about assignment, we need to clarify what an **object** is. In R, everything you work with is an object: the number `5`, the expression `1 + 2`, and even the result of `exp(3) / log(20, 3) * 7`.

Running one of those expressions prints its value: in these examples, each object has a single element. Objects can also hold multiple elements (for example, a vector of several numbers), and each element keeps its own value. In the next sections you will learn how to create named objects and control the values they store.

### Assignment Operation with `<-` {#assignment}

With objects in mind, the next step is to learn how to create a named object. The basic pattern is `name <- value`: choose a descriptive name, place the assignment operator `<-` in the middle, and supply the value you want to store. Once the object exists, you can reuse the name in later expressions without retyping the original value. Here is the simplest possible example.

```{r results = TRUE}
x_num <- 5
```

The expression has three parts: the **object name** (`x_num`), the **assignment operator** (`<-`, written with no space between `<` and `-`), and the **value** being stored (the number `5`). We will discuss naming rules in Section \@ref(Naming).

::: {.infobox .caution data-latex="{caution}"}
Keep the two characters of `<-` together. Although R also accepts `=`, we strongly recommend reserving `=` for function arguments (to be introduced in Section \@ref(intro-num-vector)); mixing the two styles easily leads to confusing code.
:::

Running the assignment prints nothing to the console (Figure \@ref(fig:noa)), unlike `1 + 2` which displays `3`. The object is created quietly in the background.

```{r noa, results=TRUE, echo=FALSE, fig.align = 'center', fig.cap="No output during the assignment operation.", out.width = '70%'}
knitr::include_graphics("pics/2noa.png")
```


To confirm the value stored in an object, run a line containing only its name. R prints the contents of the object to the console.

```{r results = TRUE}
x_num
```

Great! The output `5` shows that the name `x_num` now stores the value `5`. Anywhere you would have typed the literal number, you can now reference `x_num` instead.

Note that R object names are **case-sensitive**. For example, you have defined `x_num`, but if you type `X_num`, the console will return an error message as follow.

```{r, error = TRUE}
X_num
```

In addition, you can assign **value(s)** of an expression to a name. Let's try to simplify the three expressions we showed at the beginning of this section. It is easy to observe that the three expressions share a common term `exp(3) / log(20,3) * 7`. Let's assign the common term to a name.

```{r results = TRUE}
y_num <- exp(3) / log(20, 3) * 7
y_num
```

Now you have successfully created an object `y_num` with value `r y_num`. Using the named object `y_num`, you can simplify the three calculations as follows.

```{r, eval=FALSE}
y_num + 3
y_num - 3
y_num / 3
```

::: {.infobox .caution data-latex="{caution}"}
During assignment, the expression on the right-hand side is evaluated first and only the resulting value is stored. Running `y_num` therefore returns the numeric result, not the text of the original expression.
:::

You can also try the following examples by yourself.

```{r, results=FALSE}
z_num1 <- floor(7 / 3)
z_num1
z_num2 <- 7 %/% 3
z_num2
```

Clearly, using the object assignment, you can greatly simplify the code and avoid redundancy.

### Object Naming Rules {#Naming}

R is fairly flexible about object names, but there are three rules you must follow.

***a. Start with a letter or a single . (period)***

If you start a name with `.`, the second character cannot be a number.

***b. Use only letters, numbers, `_` (underscore), or `.` (period)***

A consistent style improves readability. We recommend all-lowercase names separated with underscores, such as `this_is_name_6` or `super_rich_88`.

***c. Avoid reserved keywords***

Names such as `TRUE`, `if`, or `function` are reserved by R and cannot be reassigned. Attempting to do so results in an error, as shown below.

```{r error=TRUE}
TRUE <- 12
```

Some commonly used reserved keywords that cannot be used as names are listed as below.

```{r results = TRUE, echo=FALSE, warning=FALSE}
knitr::kable(matrix(c("TRUE", "FALSE", "NA", "Inf",
 "NaN", "function", "if", "else", "for", "while",
  "break", "next", "repeat", "return"), 7, 2))
```

To get a complete list of reserved words, you can run the following code.

```{r, eval = FALSE}
?Reserved
```

### Review objects in environment

You can inspect your objects visually in the **Environment** pane, located in the top-right area of RStudio (panel 3 in Figure \@ref(fig:four) from Section \@ref(Installation)).

If you ran the earlier examples, you should now see objects such as `x_num`, `y_num`, and `z_num1` listed in the Environment tab (Figure \@ref(fig:en)). Reserved keywords like `TRUE` never appear because R refuses to overwrite them.

```{r en, results=TRUE, echo=FALSE, fig.align = 'center', fig.cap="The environment (I)", out.width = '70%'}
knitr::include_graphics("pics/1en.png")
```

From the screenshot above you can see that `x_num` currently stores the value 5. Let's update it to 6 and observe what changes.

```{r results = TRUE}
x_num <- 6
x_num  #check its value
```

The Environment now shows `x_num` with value 6. Assigning a new value replaces the old one. R does not keep past values once you reassign the name.

```{r en2, results=TRUE, echo=FALSE, fig.align = 'center', fig.cap="The environment (II)", out.width = '70%'}
knitr::include_graphics("pics/1en2.png")
```

Keep an eye on the Environment pane while you work to confirm objects contain what you expect. Only named objects appear there; unnamed results vanish as soon as they are printed.

You can also list the names programmatically with the built-in `ls()` function.

```{r, results = TRUE}
ls()
```

All the objects shown in the environment or on the list are stored in the memory, so they are available for us in subsequent codes. It is a good habit to do object assignments if you want to retrieve their values at a later time.

### Object types

So far in this section, you have learned how to do object assignments. The values you assigned are all numbers, i.e. of numeric type. Actually, an object may contain more than one values. Also, an object may contain values other than the numeric type, such like character and logical ones. Depending on the **composition of values**, the object belongs to one particular type.

```{r echo = FALSE, results = TRUE}
Type  <- c("Atomic Vector","Matrix","Array","Data Frame", "Tibble", "List")
Section <- c("\\@ref(r-objects)","\\@ref(matrix)","\\@ref(array)","\\@ref(dataframe)","\\@ref(tibble)","\\@ref(list)")
d <- data.frame(Type, Section)
knitr::kable(d)
```

We will focus on atomic vectors in Chapter \@ref(r-objects) and discuss other object types in Chapter \@ref(object-other-type).

While some of the object types look more intuitive than others, you have nothing to worry about since we have the next two chapters devoted to the details of R objects. Objects are the building blocks of R programming and it will be time well spent mastering every object type.

### Exercises

1.  Write the R code to assign the value 20 to the name `num_1`.

2.  Which of the following is a valid object name in R?

-   `2.True`
-   `else`
-   `I_am_not_a_valid_name`
-   `I_am_a_Pretty#_name`

3.  Write the R code to get the list of all objects in the environment.
